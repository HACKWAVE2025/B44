<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Stellar</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/default.min.css">
    <script src="/marked.min.js"></script>
    <script src="/turndown.js"></script>
    <script src="/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
        integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
        integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd"
        crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
        integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify @3.0.6/dist/purify.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/python/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>

    <style>
        :root {
            --model-color-start: #7b61ff;
            --model-color-end: #b554ff;
            --model-color-border: rgba(181, 84, 255, 0.5);
            --model-color-shadow: rgba(123, 97, 255, 0.3);
            --model-color-shadow-inset: rgba(123, 97, 255, 0.2);
            --model-hover-color-start: #b554ff;
            --model-hover-color-end: #7b61ff;
            --model-hover-color-border: rgba(123, 97, 255, 0.7);
            --model-hover-color-shadow: rgba(123, 97, 255, 0.5);
            --model-hover-color-shadow-inset: rgba(123, 97, 255, 0.3);
            --model-hover-shadow-strong: rgba(123, 97, 255, 0.4);
            --title-shadow-color: var(--model-color-shadow);
            --body-bg-color1: #0f0c29;
            --body-bg-color2: #302b63;
            --body-bg-color3: #24243e;
            --body-bg-color4: #302b63;
            --primary-text-color: #f0f0f0;
            --secondary-text-color: #a9a3c7;
            --header-bg: rgba(20, 16, 50, 0.3);
            --header-border: rgba(181, 84, 255, 0.15);
            --input-bg: rgba(20, 16, 50, 0.4);
            --input-border: rgba(181, 84, 255, 0.1);
            --input-focus-bg: rgba(30, 26, 60, 0.5);
            --input-focus-border: var(--model-color-border);
            --user-msg-bg: rgba(123, 97, 255, 0.15);
            --user-msg-border: rgba(123, 97, 255, 0.3);
            --user-msg-hover-bg: rgba(123, 97, 255, 0.2);
            --stellar-msg-bg: rgba(0, 0, 0, 0.25);
            --stellar-msg-border: rgba(123, 97, 255, 0.2);
            --stellar-msg-hover-bg: rgba(0, 0, 0, 0.35);
            --nebula-msg-bg: rgba(10, 25, 45, 0.4);
            --nebula-msg-border: rgba(79, 172, 254, 0.3);
            --nebula-msg-hover-bg: rgba(15, 35, 55, 0.5);
            --link-color: var(--model-color-start);
            --link-hover-color: var(--model-hover-color-start);
            --scrollbar-thumb-start: var(--model-color-start);
            --scrollbar-thumb-end: var(--model-color-end);
            --scrollbar-thumb-border: var(--model-color-border);
            --scrollbar-thumb-hover-start: var(--model-hover-color-start);
            --scrollbar-thumb-hover-end: var(--model-hover-color-end);
            --scrollbar-thumb-hover-border: var(--model-hover-color-border);
            --scrollbar-track-bg: rgba(36, 36, 62, 0.8);
            --table-border-color: rgba(123, 97, 255, 0.3);
            --code-bg: rgba(10, 10, 25, 0.85);
            --code-border: rgba(123, 97, 255, 0.4);
            --code-text-color: #f5f5f5;
            --inline-code-bg: rgba(0, 0, 0, 0.3);
            --inline-code-text-color: var(--model-color-end);
            --status-bar-bg: rgba(123, 97, 255, 0.2);
            --status-bar-color: #e0d9ff;
            --status-bar-shadow: rgba(123, 97, 255, 0.4);
            --status-bar-idle-color: var(--secondary-text-color);
            --status-bar-idle-bg: rgba(0, 0, 0, 0.2);
            --code-btn-bg: rgba(255, 255, 255, 0.1);
            --code-btn-hover-bg: rgba(255, 255, 255, 0.2);
            --code-btn-color: #c5bfff;
            --code-btn-hover-color: #f5f5f5;
            --copy-btn-copied-bg: var(--model-color-start);
            --copy-btn-copied-color: #ffffff;
            --preview-btn-bg: var(--code-btn-bg);
            --preview-btn-hover-bg: var(--code-btn-hover-bg);
            --preview-btn-color: var(--code-btn-color);
            --preview-btn-hover-color: var(--code-btn-hover-color);
            --transition-duration-fast: 0.2s;
            --transition-duration-medium: 0.3s;
            --transition-duration-slow: 0.5s;
            --transition-timing-function: ease;
            --transition-cubic-bezier: cubic-bezier(0.25, 0.8, 0.25, 1);
            --nebula-confirm-start: #00c292;
            --nebula-confirm-end: #00a77d;
            --nebula-regenerate-start: #ff8e8e;
            --nebula-regenerate-end: #ff6b6b;
            --nebula-button-shadow: rgba(0, 0, 0, 0.2);
            --nebula-button-hover-brightness: 1.1;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .file-upload-label-button {
            background: rgba(255, 255, 255, 0.07);
            color: var(--secondary-text-color);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
            display: inline-block;
            border: 1px solid transparent;
            line-height: 1.4;
            margin-right: 8px;
        }

        .file-upload-label-button:hover {
             background: rgba(255, 255, 255, 0.1);
             color: var(--primary-text-color);
             transform: translateY(-1px);
             box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .code-controls .run-code-btn {
            background-color: #00a77d;
            color: white;
            animation: pulse-run 2s infinite;
        }

        @keyframes pulse-run {
            0% {
                box-shadow: 0 0 0 0 rgba(0, 167, 125, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(0, 167, 125, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(0, 167, 125, 0);
            }
        }

        #analysis-progress-area {
            position: fixed;
            bottom: 130px;
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 40px);
            max-width: 1200px;
            max-height: 150px;
            overflow-y: auto;
            display: none; /* Initially hidden */
            flex-direction: column-reverse;
            gap: 8px;
            z-index: 90;
            padding: 5px;
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb-start) var(--scrollbar-track-bg);
        }
        #analysis-progress-area::-webkit-scrollbar { width: 5px; }
        #analysis-progress-area::-webkit-scrollbar-track { background: var(--scrollbar-track-bg); border-radius: 10px; }
        #analysis-progress-area::-webkit-scrollbar-thumb { background: linear-gradient(var(--scrollbar-thumb-start), var(--scrollbar-thumb-end)); border-radius: 10px; border: 1px solid var(--scrollbar-thumb-border); }
        #analysis-progress-area::-webkit-scrollbar-thumb:hover { background: linear-gradient(var(--scrollbar-thumb-hover-start), var(--scrollbar-thumb-hover-end)); border: 1px solid var(--scrollbar-thumb-hover-border); }

        .file-progress-item {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
            border: 1px solid var(--stellar-msg-border);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            color: var(--secondary-text-color);
            transition: border-color 0.3s ease, background-color 0.3s ease, opacity 0.5s ease;
            animation: progressIn 0.3s ease forwards;
            opacity: 0;
            transform: translateY(10px);
        }
        @keyframes progressIn { to { opacity: 1; transform: translateY(0); } }

        .file-progress-item .summary { cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .file-progress-item .summary strong { color: var(--primary-text-color); margin-right: 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 70%; }
        .file-progress-item .summary .status { font-style: italic; white-space: nowrap; }
        .file-progress-item .details { display: none; padding-top: 5px; margin-top: 5px; border-top: 1px dashed rgba(255, 255, 255, 0.15); font-size: 0.8rem; max-height: 80px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: var(--scrollbar-thumb-start) var(--scrollbar-track-bg); }
        .file-progress-item.status-success { border-color: var(--nebula-confirm-start); background-color: rgba(0, 194, 146, 0.1); }
        .file-progress-item.status-success .summary .status { color: var(--nebula-confirm-start); font-style: normal; }
        .file-progress-item.status-error { border-color: var(--nebula-regenerate-start); background-color: rgba(211, 16, 39, 0.1); }
        .file-progress-item.status-error .summary .status { color: var(--nebula-regenerate-start); font-style: normal; }
        .file-progress-item.status-finished, .file-progress-item.status-ended { border-color: var(--model-color-border); background-color: rgba(123, 97, 255, 0.1); }

        .placeholder-message .message-content { font-style: italic; color: var(--secondary-text-color); }
        .placeholder-status.clickable { cursor: pointer; text-decoration: underline dotted; }
        .analysis-indicator.clickable { cursor: pointer; text-decoration: underline dotted; }
        .analysis-content { font-size: 0.9em; line-height: 1.4; }
        .analysis-content small { display: block; margin-bottom: 5px; color: var(--secondary-text-color); }
        .formatted-analysis-context ul { list-style: disc; margin-left: 20px; margin-top: 5px; margin-bottom: 10px; }
        .formatted-analysis-context li { margin-bottom: 8px; }
        .formatted-analysis-context pre { margin-top: 5px; padding: 8px; font-size: 0.85em; background-color: rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.1); white-space: pre-wrap; word-wrap: break-word; }
        .formatted-analysis-context details { border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; margin-bottom: 10px; background-color: rgba(0, 0, 0, 0.1); }
        .formatted-analysis-context summary { padding: 8px; cursor: pointer; font-weight: bold; color: var(--primary-text-color); }
        .formatted-analysis-context summary:hover { background-color: rgba(255, 255, 255, 0.05); }
        .formatted-analysis-context details > div, .formatted-analysis-context details > pre { padding: 10px; border-top: 1px dashed rgba(255, 255, 255, 0.1); margin-top: 0; }
        .formatted-analysis-context .rendered-markdown-block { margin-top: 5px; padding: 10px; background-color: rgba(0,0,0,0.15); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; }
        .formatted-analysis-context .rendered-markdown-block pre { background-color: rgba(0,0,0,0.25); border: 1px solid rgba(255,255,255,0.15); }
        .formatted-analysis-context strong { color: var(--primary-text-color); } /* Ensure bold text is readable */

        #chatInput, .modal-content, #editMarkdownInput, #regenerateFeedbackInput { scrollbar-width: none; -ms-overflow-style: none; }
        #messages::-webkit-scrollbar { display: none; }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, var(--body-bg-color1), var(--body-bg-color2), var(--body-bg-color3), var(--body-bg-color4));
            background-size: 400% 400%;
            color: var(--primary-text-color);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden;
            transition: color var(--transition-duration-slow) var(--transition-timing-function);
            animation: animatedGradient 20s ease infinite;
        }
        @keyframes animatedGradient { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }

        .bg-glow { position: fixed; border-radius: 50%; filter: blur(100px); opacity: 0.2; pointer-events: none; z-index: -1; transition: background 0.5s ease; }
        .glow-1 { width: 500px; height: 500px; background: radial-gradient(circle, var(--model-color-start) 0%, rgba(123, 97, 255, 0) 70%); top: -150px; left: -150px; animation: float 15s infinite ease-in-out alternate; }
        .glow-2 { width: 400px; height: 400px; background: radial-gradient(circle, var(--model-color-end) 0%, rgba(181, 84, 255, 0) 70%); bottom: -100px; right: -100px; animation: float 18s infinite ease-in-out alternate-reverse; }
        .glow-3 { width: 300px; height: 300px; background: radial-gradient(circle, #8fd3f4 0%, rgba(143, 211, 244, 0) 70%); top: 50%; left: 50%; transform: translate(-50%, -50%); animation: float 20s infinite ease-in-out; opacity: 0.1; }
        @keyframes float { 0% { transform: translate(0, 0) scale(1); } 50% { transform: translate(50px, -30px) scale(1.1); } 100% { transform: translate(-30px, 30px) scale(0.9); } }

        header { background: var(--header-bg); backdrop-filter: blur(12px); padding: 15px 24px; display: flex; align-items: center; justify-content: space-between; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2); position: sticky; top: 0; z-index: 100; border-bottom: 1px solid var(--header-border); transition: background var(--transition-duration-medium) var(--transition-timing-function), border-color var(--transition-duration-medium) var(--transition-timing-function); }
        .title-gradient { font-size: 1.8rem; font-weight: 600; background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 15px var(--title-shadow-color); letter-spacing: 1px; transition: text-shadow var(--transition-duration-medium) var(--transition-timing-function), transform var(--transition-duration-fast) var(--transition-timing-function), background var(--transition-duration-medium) var(--transition-timing-function); }
        .title-gradient:hover { text-shadow: 0 0 20px var(--model-hover-color-shadow); transform: translateY(-1px); }
        body.theme-emerald .title-gradient { background: linear-gradient(45deg, #00c292, #00a77d 50%, #36d1dc); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 10px var(--title-shadow-color); }
        body.theme-crimson .title-gradient { background: linear-gradient(45deg, #D31027, #9A0007 50%, #ff512f); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 10px var(--title-shadow-color); }
        body.theme-obsidian .title-gradient { background: linear-gradient(45deg, #6e7a85, #485563 50%, #8a9aa3); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 0 12px var(--title-shadow-color), 0 0 1px rgba(200, 210, 220, 0.3); filter: brightness(1.1); }
        .clear-icon { font-size: 1.2rem; background: none; border: none; color: #ff6b6b; cursor: pointer; padding: 4px; transition: color var(--transition-duration-fast) var(--transition-timing-function), transform var(--transition-duration-fast) var(--transition-timing-function), box-shadow var(--transition-duration-fast) var(--transition-timing-function); }
        .clear-icon:hover { color: #ff8e8e; transform: translateY(-2px) scale(1.1); box-shadow: 0 4px 10px rgba(255, 107, 107, 0.3); filter: brightness(1.2); }

        #chatContainer { flex: 1; display: flex; flex-direction: column; width: 100%; margin: 0 auto; padding: 30px max(20px, calc((100% - 1200px) / 2)); position: relative; padding-bottom: 220px; box-sizing: border-box; }

        #messages {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 15px;
            width: 100%;
            box-sizing: border-box;
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb-start) var(--scrollbar-track-bg);
        }
        #messages::-webkit-scrollbar { width: 8px; }
        #messages::-webkit-scrollbar-track { background: var(--scrollbar-track-bg); border-radius: 10px; margin: 5px 0; }
        #messages::-webkit-scrollbar-thumb { background: linear-gradient(var(--scrollbar-thumb-start), var(--scrollbar-thumb-end)); border-radius: 10px; border: 1px solid var(--scrollbar-thumb-border); }
        #messages::-webkit-scrollbar-thumb:hover { background: linear-gradient(var(--scrollbar-thumb-hover-start), var(--scrollbar-thumb-hover-end)); border: 1px solid var(--scrollbar-thumb-hover-border); }

        .message { margin-bottom: 20px; line-height: 1.6; word-wrap: break-word; padding: 18px 22px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15); border: 1px solid transparent; animation: messageIn 0.4s ease forwards; opacity: 0; transform: translateY(20px); transition: background var(--transition-duration-medium) var(--transition-timing-function), border-color var(--transition-duration-medium) var(--transition-timing-function), transform var(--transition-duration-fast) ease-out; max-width: 90%; box-sizing: border-box; }
        .message:hover { transform: translateY(-2px); }
        @keyframes messageIn { to { opacity: 1; transform: translateY(0); } }

        .user-msg { background: var(--user-msg-bg); align-self: flex-end; margin-left: auto; border-top-right-radius: 4px; border-left: 1px solid var(--user-msg-border); color: var(--primary-text-color); }
        .user-msg:hover { background: var(--user-msg-hover-bg); }
        .user-msg .message-content { white-space: pre-wrap; }
        .stellar-msg { background: var(--stellar-msg-bg); align-self: flex-start; color: var(--primary-text-color); border-top-left-radius: 4px; border-right: 1px solid var(--stellar-msg-border); }
        .stellar-msg:hover { background: var(--stellar-msg-hover-bg); }

        .research-output { background: rgba(0, 0, 0, 0.4); color: var(--primary-text-color); border: 1px solid var(--stellar-msg-border); box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25); position: relative; align-self: stretch; margin-left: 0; max-width: none; width: auto; resize: horizontal; overflow: auto; min-width: 400px; }
        .research-output:hover { background: rgba(0, 0, 0, 0.5); border-color: var(--model-color-border); }
        body.theme-emerald .research-output { border-color: rgba(0, 194, 146, 0.4); }
        body.theme-emerald .research-output:hover { border-color: rgba(0, 194, 146, 0.6); }
        body.theme-crimson .research-output { border-color: rgba(211, 16, 39, 0.4); }
        body.theme-crimson .research-output:hover { border-color: rgba(211, 16, 39, 0.6); }
        body.theme-obsidian .research-output { border-color: rgba(72, 85, 99, 0.4); }
        body.theme-obsidian .research-output:hover { border-color: rgba(72, 85, 99, 0.6); }
        .research-output a, .nebula-output a { color: var(--link-color); text-decoration: none; border-bottom: 1px dotted var(--link-color); transition: color var(--transition-duration-fast), border-color var(--transition-duration-fast); }
        .research-output a:hover, .nebula-output a:hover { color: var(--link-hover-color); border-bottom: 1px solid var(--link-hover-color); }
        .research-output .message-content pre, .nebula-output .message-content pre { background-color: var(--code-bg); border: 1.5px solid var(--code-border); color: var(--code-text-color); overflow-x: auto; }
        .research-output .message-content code:not(pre>code), .nebula-output .message-content code:not(pre>code) { background-color: var(--inline-code-bg); color: var(--inline-code-text-color); }
        .research-output .message-content .table-wrapper, .nebula-output .message-content .table-wrapper { border: 1px solid var(--table-border-color); overflow-x: auto; max-width: 100%; }
        .research-output .message-content table, .nebula-output .message-content table { border: none; border-color: var(--table-border-color); }
        .research-output .message-content td, .research-output .message-content th, .nebula-output .message-content td, .nebula-output .message-content th { border-color: var(--table-border-color); }
        .research-output .message-content th, .nebula-output .message-content th { background-color: rgba(0, 0, 0, 0.1); }
        .research-output .message-buttons, .nebula-output .message-buttons { margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255, 255, 255, 0.1); display: flex; gap: 10px; justify-content: flex-start; }
        .research-output::-webkit-resizer { border-width: 0 0 8px 8px; border-style: solid; border-color: transparent transparent var(--model-color-border) var(--model-color-border); background: transparent; display: block; width: 12px; height: 12px; position: absolute; bottom: 0; right: 0; cursor: nwse-resize; }

        .nebula-output { background: var(--nebula-msg-bg); align-self: stretch; color: var(--primary-text-color); border: 1px solid var(--nebula-msg-border); max-width: none; margin-left: 0; box-shadow: 0 6px 20px rgba(0, 30, 50, 0.3); resize: horizontal; overflow: auto; min-width: 400px; }
        .nebula-output:hover { background: var(--nebula-msg-hover-bg); border-color: var(--model-color-start); }
        .nebula-output .message-content h2 { margin-bottom: 1em; border-bottom: 1px solid var(--nebula-msg-border); padding-bottom: 0.3em; color: var(--link-color); font-size: 1.3em; }
        .nebula-output .message-content h3 { margin-top: 1.5em; margin-bottom: 0.5em; color: var(--primary-text-color); font-weight: 600; font-size: 1.1em; border-bottom: 1px dashed rgba(255, 255, 255, 0.15); padding-bottom: 0.2em; }
        .nebula-output .nebula-status { font-size: 0.8em; font-style: italic; color: var(--secondary-text-color); margin-left: 5px; }
        .nebula-output .nebula-steps-container { margin-top: 1em; }
        .nebula-output .nebula-step-content { margin-bottom: 1.5em; }
        .nebula-output .nebula-final-summary { margin-top: 1.5em; padding-top: 1em; border-top: 1px solid var(--nebula-msg-border); font-size: 0.95em; }
        .nebula-output::-webkit-resizer { border-width: 0 0 8px 8px; border-style: solid; border-color: transparent transparent var(--model-color-border) var(--model-color-border); background: transparent; display: block; width: 12px; height: 12px; position: absolute; bottom: 0; right: 0; cursor: nwse-resize; }
        .stellar-msg:not(.research-output):not(.nebula-output) a { color: var(--link-color); text-decoration: none; border-bottom: 1px dotted var(--link-color); transition: color var(--transition-duration-fast) var(--transition-timing-function), border-color var(--transition-duration-fast) var(--transition-timing-function); }
        .stellar-msg:not(.research-output):not(.nebula-output) a:hover { color: var(--link-hover-color); border-bottom: 1px solid var(--link-hover-color); }

        .edit-paper-btn, .download-btn, #spectrumBtn, #spectrumSearchBtn, #nebulaBtn, #sendBtn, .modal-buttons button, .code-block-btn, .nebula-download-btn, .nebula-confirm-btn, .nebula-regenerate-btn { padding: 8px 16px; font-size: 0.9rem; border: none; border-radius: 6px; color: #fff; cursor: pointer; transition: background var(--transition-duration-medium) var(--transition-cubic-bezier), border-color var(--transition-duration-medium) var(--transition-cubic-bezier), box-shadow var(--transition-duration-medium) var(--transition-cubic-bezier), transform var(--transition-duration-fast) var(--transition-cubic-bezier), filter var(--transition-duration-fast) var(--transition-cubic-bezier), color var(--transition-duration-medium) var(--transition-cubic-bezier), opacity var(--transition-duration-fast); line-height: 1.4; }
        .nebula-confirm-btn:disabled, .nebula-regenerate-btn:disabled { cursor: not-allowed; opacity: 0.6; }
        .edit-paper-btn { background: linear-gradient(45deg, #ff8e8e, #ff6b6b); box-shadow: 0 4px 10px rgba(255, 107, 107, 0.3); }
        .download-btn { background: linear-gradient(45deg, #00c292, #00d8b6); box-shadow: 0 4px 10px rgba(0, 216, 182, 0.3); }
        .nebula-download-btn { background: linear-gradient(45deg, #4facfe, #00f2fe); box-shadow: 0 4px 10px rgba(79, 172, 254, 0.3); text-decoration: none; display: inline-block; }
        #spectrumBtn, #spectrumSearchBtn, #nebulaBtn { background: rgba(255, 255, 255, 0.07); color: var(--secondary-text-color); box-shadow: none; border: 1px solid transparent; }
        #sendBtn { background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end)); box-shadow: 0 4px 10px var(--model-color-shadow); border-radius: 8px; }
        .modal-buttons button { padding: 12px 20px; font-weight: 500; border-radius: 8px; }
        #cancelEditBtn { background: rgba(255, 255, 255, 0.1); color: #fff; border: 1px solid rgba(255, 255, 255, 0.2); }
        #saveEditBtn { background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end)); color: #fff; box-shadow: 0 4px 15px var(--model-color-shadow); }
        .nebula-step-actions { margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255, 255, 255, 0.1); display: flex; gap: 10px; justify-content: flex-start; transition: opacity var(--transition-duration-fast); }
        .nebula-confirm-btn { background: linear-gradient(45deg, var(--nebula-confirm-start), var(--nebula-confirm-end)); box-shadow: 0 2px 6px var(--nebula-button-shadow); }
        .nebula-regenerate-btn { background: linear-gradient(45deg, var(--nebula-regenerate-start), var(--nebula-regenerate-end)); box-shadow: 0 2px 6px var(--nebula-button-shadow); }
        .nebula-confirm-btn:hover:not(:disabled), .nebula-regenerate-btn:hover:not(:disabled) { transform: translateY(-1px); filter: brightness(var(--nebula-button-hover-brightness)); box-shadow: 0 4px 8px var(--nebula-button-shadow); }
        .edit-paper-btn:hover, .download-btn:hover, .nebula-download-btn:hover { transform: translateY(-2px) scale(1.03); filter: brightness(1.1); }
        .edit-paper-btn:hover { box-shadow: 0 6px 15px rgba(255, 107, 107, 0.4); }
        .download-btn:hover { box-shadow: 0 6px 15px rgba(0, 216, 182, 0.4); }
        .nebula-download-btn:hover { box-shadow: 0 6px 15px rgba(79, 172, 254, 0.4); background: linear-gradient(45deg, #00f2fe, #4facfe); }
        #spectrumBtn.active, #spectrumSearchBtn.on, #nebulaBtn.active { background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end)); border: 1px solid var(--model-color-border); box-shadow: 0 4px 10px var(--model-color-shadow); color: #fff; }
        #spectrumBtn:disabled, #spectrumSearchBtn:disabled, #nebulaBtn:disabled { background: linear-gradient(45deg, #333, #444); border: 1px solid #555; color: #777; cursor: not-allowed; opacity: 0.6; pointer-events: none; transform: none !important; filter: none !important; box-shadow: none !important; }
        #spectrumBtn.active:hover:not(:disabled), #spectrumSearchBtn.on:hover:not(:disabled), #nebulaBtn.active:hover:not(:disabled) { background: linear-gradient(45deg, var(--model-hover-color-start), var(--model-hover-color-end)); border-color: var(--model-hover-color-border); transform: translateY(-2px) scale(1.05); filter: brightness(1.15); box-shadow: 0 8px 20px var(--model-hover-color-shadow); }
        #spectrumBtn:hover:not(:disabled):not(.active), #spectrumSearchBtn:hover:not(:disabled):not(.on), #nebulaBtn:hover:not(:disabled):not(.active) { background: rgba(255, 255, 255, 0.1); color: var(--primary-text-color); transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); }
        #spectrumSearchBtn { display: none; }
        #sendBtn:hover { background: linear-gradient(45deg, var(--model-hover-color-start), var(--model-hover-color-end)); transform: translateY(-3px) scale(1.08); filter: brightness(1.2) contrast(1.1); box-shadow: 0 10px 25px var(--model-hover-shadow-strong); }
        #sendBtn:active { transform: translateY(0) scale(1); filter: brightness(0.9); transition-duration: 0.1s; }
        #sendBtn:disabled { background: linear-gradient(45deg, #555, #666); border: 1px solid #777; color: #999; cursor: not-allowed; opacity: 0.7; pointer-events: none; transform: none !important; filter: none !important; box-shadow: none !important; }
        #cancelEditBtn:hover { background: rgba(255, 255, 255, 0.15); transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }
        #saveEditBtn:hover { background: linear-gradient(45deg, var(--model-hover-color-start), var(--model-hover-color-end)); transform: translateY(-2px); box-shadow: 0 8px 20px var(--model-hover-color-shadow); }
        #saveEditBtn:active, #cancelEditBtn:active { transform: translateY(0); }

        #statusBar { position: fixed; width: calc(100% - 40px); margin: 0 auto; text-align: center; padding: 8px; font-size: 0.95rem; color: var(--status-bar-idle-color); background: var(--status-bar-idle-bg); border-radius: 8px; height: 30px; opacity: 0.7; transform: translateY(15px) translateX(-50%); display: flex; align-items: center; justify-content: center; z-index: 99; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; border: 1px solid transparent; left: 50%; bottom: 0; transition: all 0.8s var(--transition-cubic-bezier), background var(--transition-duration-medium) var(--transition-timing-function), color var(--transition-duration-medium) var(--transition-timing-function), box-shadow var(--transition-duration-medium) var(--transition-timing-function), border-color var(--transition-duration-medium) var(--transition-timing-function); max-width: 1200px; }
        #statusBar.active { background: var(--status-bar-bg); color: var(--status-bar-color); box-shadow: 0 0 20px var(--status-bar-shadow); border: 1px solid var(--model-color-border); opacity: 1; transform: translateY(5px) translateX(-50%); white-space: normal; padding: 12px; animation: statusBarPulse 2.5s infinite alternate ease-in-out; }
        @keyframes statusBarPulse { 0% { box-shadow: 0 0 15px var(--status-bar-shadow); opacity: 0.9; } 100% { box-shadow: 0 0 25px var(--status-bar-shadow); opacity: 1; } }
        #statusBar.error { background: rgba(255, 107, 107, 0.3); color: #ff8e8e; box-shadow: 0 0 20px rgba(255, 107, 107, 0.4); border-color: rgba(255, 107, 107, 0.5); animation: none; }

        #inputContainer { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); width: calc(100% - 40px); margin: 0 auto; padding: 8px 16px; background: var(--input-bg); backdrop-filter: blur(12px); border-radius: 12px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2); border: 1px solid var(--input-border); z-index: 100; display: flex; flex-direction: column; gap: 5px; transition: background var(--transition-duration-medium) var(--transition-timing-function), border-color var(--transition-duration-medium) var(--transition-timing-function), box-shadow var(--transition-duration-medium) var(--transition-timing-function); max-width: 1200px; box-sizing: border-box; }
        #inputContainer:focus-within { background: var(--input-focus-bg); box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3); border: 1px solid var(--input-focus-border); }
        #chatInput { width: 100%; padding: 8px 12px; font-size: 1rem; border: none; background: transparent; color: var(--primary-text-color); outline: none; resize: none; overflow-y: auto; min-height: 24px; max-height: 240px; transition: background var(--transition-duration-medium) var(--transition-timing-function); }
        #chatInput::placeholder { color: rgba(255, 255, 255, 0.5); transition: color var(--transition-duration-medium) var(--transition-timing-function); }
        #chatInput:focus::placeholder { color: rgba(255, 255, 255, 0.3); }
        .input-buttons { display: flex; align-items: center; justify-content: space-between; width: 100%; }
        .left-buttons, .right-buttons { display: flex; align-items: center; gap: 8px; }
        #modelSelectWidthHelper { position: absolute; visibility: hidden; white-space: nowrap; font-size: 0.9rem; font-family: 'Poppins', sans-serif; padding: 8px 14px; display: inline-block; }
        #modelSelect { background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end)); border: 1px solid var(--model-color-border); box-shadow: 0 0 10px var(--model-color-shadow), inset 0 0 5px var(--model-color-shadow-inset); color: #ffffff; padding: 8px 14px; font-size: 0.9rem; border-radius: 6px; cursor: pointer; appearance: none; -webkit-appearance: none; -moz-appearance: none; position: relative; text-align: center; text-align-last: center; width: auto; min-width: 80px; transition: background var(--transition-duration-medium) var(--transition-cubic-bezier), border-color var(--transition-duration-medium) var(--transition-cubic-bezier), box-shadow var(--transition-duration-medium) var(--transition-cubic-bezier), transform var(--transition-duration-fast) var(--transition-cubic-bezier), filter var(--transition-duration-fast) var(--transition-cubic-bezier); }
        #modelSelect:hover, #modelSelect:focus { background: linear-gradient(45deg, var(--model-hover-color-start), var(--model-hover-color-end)); border-color: var(--model-hover-color-border); box-shadow: 0 0 15px var(--model-hover-color-shadow), inset 0 0 8px var(--model-hover-color-shadow-inset); color: #ffffff; transform: translateY(-2px) scale(1.03); filter: brightness(1.1); outline: none; }
        #modelSelect option { background: var(--input-bg, #24243e); color: var(--primary-text-color, #D3D3D3); padding: 10px 14px; text-align: left; transition: background var(--transition-duration-fast) var(--transition-timing-function), color var(--transition-duration-fast) var(--transition-timing-function); }
        #modelSelect option:hover { background: linear-gradient(45deg, var(--model-hover-color-start), var(--model-hover-color-end)); color: #ffffff; }
        #modelSelect option:checked { background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end)); color: #ffffff; font-weight: 600; }
        #modelSelect option:disabled { color: #888 !important; background-color: #555 !important; cursor: not-allowed !important; opacity: 0.7; pointer-events: none; }

        #editModalBackdrop, #regenerateModalBackdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(15, 12, 41, 0.8); backdrop-filter: blur(8px); display: none; align-items: center; justify-content: center; z-index: 999; animation: fadeIn var(--transition-duration-medium) var(--transition-timing-function); }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .modal-content { background: linear-gradient(135deg, rgba(48, 43, 99, 0.8), rgba(36, 36, 62, 0.9)); border: 1px solid var(--model-color-border); border-radius: 16px; backdrop-filter: blur(20px); padding: 30px; width: 90%; max-width: 800px; box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4); animation: modalIn 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55); transform: translateY(0) scale(1); overflow-y: auto; max-height: 90vh; transition: border-color var(--transition-duration-medium) var(--transition-timing-function); }
        @keyframes modalIn { from { opacity: 0; transform: translateY(40px) scale(0.9); } to { opacity: 1; transform: translateY(0) scale(1); } }
        .modal-content h2 { font-size: 1.5rem; margin-bottom: 20px; text-align: center; background: linear-gradient(45deg, var(--model-color-start, #7b61ff), var(--model-color-end, #b554ff)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; letter-spacing: 1px; transition: background var(--transition-duration-medium) var(--transition-timing-function); }
        #editMarkdownInput { width: 100%; padding: 15px; font-size: 1rem; border: 1px solid var(--model-color-border); border-radius: 8px; background: rgba(0, 0, 0, 0.4); color: var(--primary-text-color); margin-bottom: 25px; outline: none; box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2); min-height: 250px; resize: vertical; overflow-y: auto; transition: all var(--transition-duration-medium) var(--transition-timing-function); font-family: monospace; }
        #editMarkdownInput:focus { border: 1px solid var(--model-hover-color-border); background: rgba(0, 0, 0, 0.5); box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2), 0 0 15px var(--model-hover-color-shadow); }
        .modal-buttons { display: flex; justify-content: flex-end; gap: 15px; margin-top: 10px; }
        #regenerateFeedbackInput { width: 100%; padding: 12px; font-size: 0.95rem; border: 1px solid var(--model-color-border); border-radius: 6px; background: rgba(0, 0, 0, 0.4); color: var(--primary-text-color); margin-bottom: 20px; outline: none; box-shadow: inset 0 1px 5px rgba(0, 0, 0, 0.2); min-height: 100px; resize: vertical; transition: all var(--transition-duration-medium) var(--transition-timing-function); font-family: 'Poppins', sans-serif; }
        #regenerateFeedbackInput:focus { border-color: var(--model-hover-color-border); background: rgba(0, 0, 0, 0.5); box-shadow: inset 0 1px 5px rgba(0, 0, 0, 0.2), 0 0 10px var(--model-hover-color-shadow); }
        #regenerateWithoutFeedbackBtn { background: var(--stellar-msg-bg) !important; color: var(--secondary-text-color) !important; border: 1px solid var(--stellar-msg-border) !important; padding: 12px 20px; font-weight: 500; border-radius: 8px; margin-left: 10px; }
        #regenerateWithoutFeedbackBtn:hover { background: var(--stellar-msg-hover-bg) !important; color: var(--primary-text-color) !important; transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }
        .modal-buttons #cancelRegenerateBtn { background: rgba(255, 255, 255, 0.2); color: var(--primary-text-color); border: 1px solid rgba(255, 255, 255, 0.3); padding: 12px 20px; font-weight: 500; border-radius: 8px; cursor: pointer; transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; }
        .modal-buttons #cancelRegenerateBtn:hover { background: rgba(255, 255, 255, 0.3); transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }
        .modal-buttons #saveRegenerateBtn { background: linear-gradient(45deg, var(--model-color-start, #7b61ff), var(--model-color-end, #b554ff)); color: #fff; box-shadow: 0 4px 15px var(--model-color-shadow, rgba(123, 97, 255, 0.3)); padding: 12px 20px; font-weight: 500; border-radius: 8px; border: none; cursor: pointer; transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; }
        .modal-buttons #saveRegenerateBtn:hover { background: linear-gradient(45deg, var(--model-hover-color-start, #b554ff), var(--model-hover-color-end, #7b61ff)); transform: translateY(-2px); box-shadow: 0 8px 20px var(--model-hover-color-shadow, rgba(123, 97, 255, 0.5)); }
        .modal-buttons #regenerateWithoutFeedbackBtn { background: var(--stellar-msg-bg, rgba(0, 0, 0, 0.25)); color: var(--secondary-text-color); border: 1px solid var(--stellar-msg-border, rgba(123, 97, 255, 0.2)); padding: 12px 20px; font-weight: 500; border-radius: 8px; cursor: pointer; transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; }
        .modal-buttons #regenerateWithoutFeedbackBtn:hover { background: var(--stellar-msg-hover-bg, rgba(0, 0, 0, 0.35)); color: var(--primary-text-color); transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }
        #saveRegenerateBtn { background: linear-gradient(45deg, var(--model-color-start), var(--model-color-end)); color: #fff; box-shadow: 0 4px 15px var(--model-color-shadow); padding: 12px 20px; font-weight: 500; border-radius: 8px; border: none; cursor: pointer; transition: background var(--transition-duration-medium) var(--transition-cubic-bezier), border-color var(--transition-duration-medium) var(--transition-cubic-bezier), box-shadow var(--transition-duration-medium) var(--transition-cubic-bezier), transform var(--transition-duration-fast) var(--transition-cubic-bezier), filter var(--transition-duration-fast) var(--transition-cubic-bezier), color var(--transition-duration-medium) var(--transition-cubic-bezier), opacity var(--transition-duration-fast); line-height: 1.4; }
        #saveRegenerateBtn:hover { background: linear-gradient(45deg, var(--model-hover-color-start), var(--model-hover-color-end)); transform: translateY(-2px); box-shadow: 0 8px 20px var(--model-hover-color-shadow); }
        #cancelRegenerateBtn { background: rgba(255, 255, 255, 0.1); color: var(--primary-text-color); border: 1px solid rgba(255, 255, 255, 0.2); padding: 12px 20px; font-weight: 500; border-radius: 8px; cursor: pointer; transition: background var(--transition-duration-medium) var(--transition-cubic-bezier), border-color var(--transition-duration-medium) var(--transition-cubic-bezier), box-shadow var(--transition-duration-medium) var(--transition-cubic-bezier), transform var(--transition-duration-fast) var(--transition-cubic-bezier), filter var(--transition-duration-fast) var(--transition-cubic-bezier), color var(--transition-duration-medium) var(--transition-cubic-bezier), opacity var(--transition-duration-fast); line-height: 1.4; }
        #cancelRegenerateBtn:hover { background: rgba(255, 255, 255, 0.15); transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }
        #regenerateWithoutFeedbackBtn { background: var(--stellar-msg-bg) !important; color: var(--secondary-text-color) !important; border: 1px solid var(--stellar-msg-border) !important; padding: 12px 20px; font-weight: 500; border-radius: 8px; margin-left: 10px; cursor: pointer; transition: background var(--transition-duration-medium) var(--transition-cubic-bezier), border-color var(--transition-duration-medium) var(--transition-cubic-bezier), box-shadow var(--transition-duration-medium) var(--transition-cubic-bezier), transform var(--transition-duration-fast) var(--transition-cubic-bezier), filter var(--transition-duration-fast) var(--transition-cubic-bezier), color var(--transition-duration-medium) var(--transition-cubic-bezier), opacity var(--transition-duration-fast); line-height: 1.4; }
        #regenerateWithoutFeedbackBtn:hover { background: var(--stellar-msg-hover-bg) !important; color: var(--primary-text-color) !important; transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }

        @media (max-width: 1300px) { #chatContainer { padding-left: 30px; padding-right: 30px; } #inputContainer, #statusBar { max-width: calc(100% - 60px); } }
        @media (max-width: 768px) { header { padding: 15px; } .clear-icon { font-size: 1rem; } #chatContainer { padding: 20px 15px; padding-bottom: 200px; } .message:not(.research-output):not(.nebula-output) { max-width: 95%; } .research-output, .nebula-output { min-width: calc(100% - 30px); } #statusBar { margin: 0 15px; width: calc(100% - 30px); max-width: calc(100% - 30px); transform: translateY(15px) translateX(-50%); left: 50%; } #statusBar.active { transform: translateY(5px) translateX(-50%); } .modal-content { padding: 20px; max-width: calc(100% - 30px); } #inputContainer { padding: 8px; width: calc(100% - 30px); max-width: calc(100% - 30px); left: 50%; transform: translateX(-50%); } }
        @media (max-width: 480px) { .input-buttons { flex-direction: column; align-items: stretch; gap: 8px; } .left-buttons, .right-buttons { justify-content: space-between; width: 100%; } .right-buttons { margin-top: 5px; } #modelSelect { flex-grow: 1; } #sendBtn { padding: 10px; } .research-output, .nebula-output { min-width: calc(100% - 30px); } .modal-buttons { flex-wrap: wrap; justify-content: center; } .modal-buttons button { margin-bottom: 5px; } }

        .message-content { word-wrap: break-word; overflow-wrap: break-word; white-space: normal; }
        .code-content-original { position: relative; margin: 1.2em 0; }
        .message-content pre { white-space: pre-wrap; word-wrap: break-word; overflow-x: auto; background-color: var(--code-bg); padding: 18px; padding-top: 45px; border-radius: 8px; border: 1.5px solid var(--code-border); color: var(--code-text-color); transition: background-color var(--transition-duration-medium), border-color var(--transition-duration-medium), color var(--transition-duration-medium), box-shadow var(--transition-duration-medium); box-shadow: 0 3px 8px rgba(0, 0, 0, 0.25); font-family: 'Fira Code', Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; font-size: 0.95rem; line-height: 1.6; tab-size: 4; -moz-tab-size: 4; display: block; }
        .code-block-btn { padding: 4px 10px; font-size: 0.8rem; border: 1px solid transparent; border-radius: 4px; cursor: pointer; opacity: 0.7; transition: all var(--transition-duration-fast) ease; z-index: 1; position: absolute; top: 8px; }
        .copy-code-btn { right: 8px; background-color: var(--code-btn-bg); color: var(--code-btn-color); }
        .preview-code-btn { right: 60px; background-color: var(--preview-btn-bg); color: var(--preview-btn-color); }
        .code-content-original:hover .code-block-btn { opacity: 1; }
        .code-block-btn:hover { transform: scale(1.05); }
        .copy-code-btn:hover { background-color: var(--code-btn-hover-bg); color: var(--code-btn-hover-color); }
        .preview-code-btn:hover { background-color: var(--preview-btn-hover-bg); color: var(--preview-btn-hover-color); }
        .copy-code-btn.copied { background-color: var(--copy-btn-copied-bg); color: var(--copy-btn-copied-color); opacity: 1; }
        .code-preview-iframe { width: 100%; height: 400px; border: 1px solid var(--code-border); border-radius: 4px; background-color: #ffffff; display: block; margin: 0; }
        .message-content code:not(pre>code) { background-color: var(--inline-code-bg); padding: 0.2em 0.4em; margin: 0; font-size: 85%; border-radius: 3px; color: var(--inline-code-text-color); transition: background-color var(--transition-duration-medium), color var(--transition-duration-medium); }
        .message-content .table-wrapper { overflow-x: auto; max-width: 100%; margin: 1em 0; border: 1px solid var(--table-border-color); border-radius: 4px; transition: border-color var(--transition-duration-medium); }
        .message-content table { width: 100%; border-collapse: collapse; margin: 0; border: none; }
        .message-content td, .message-content th { padding: 10px; border: 1px solid var(--table-border-color); text-align: left; white-space: normal; word-break: break-word; border-width: 0 0 1px 0; transition: border-color var(--transition-duration-medium); }
        .message-content tr td:first-child, .message-content tr th:first-child { border-left: none; }
        .message-content tr td:last-child, .message-content tr th:last-child { border-right: none; }
        .message-content tr:last-child td { border-bottom: none; }
        .message-content th { background-color: rgba(0, 0, 0, 0.1); font-weight: 600; transition: background-color var(--transition-duration-medium); }
        .message-content ul, .message-content ol { margin-left: 1.6em; margin-top: 0.5em; margin-bottom: 0.5em; }
        .hljs { background: transparent !important; color: inherit !important; border-radius: inherit; }
        .hljs-comment, .hljs-quote { color: #8a93a0; font-style: italic; }
        .hljs-keyword, .hljs-selector-tag, .hljs-built_in, .hljs-name, .hljs-tag { color: var(--link-color); font-weight: 600; }
        .hljs-string, .hljs-regexp, .hljs-symbol, .hljs-variable, .hljs-template-variable, .hljs-link, .hljs-selector-attr, .hljs-selector-pseudo { color: #9ece6a; }
        .hljs-number, .hljs-literal { color: #fabd2f; }
        .katex-display { text-align: center; margin: 1em 0; }
        .katex-display > .katex { display: inline-block; text-align: initial; }
    </style>
</head>

<body>

    <header>
        <div class="title-gradient">Stellar</div>
        <button class="clear-icon" id="clearHistoryBtn">ğŸ—‘ï¸</button>
    </header>

    <div id="chatContainer">
        <div id="messages"></div>
        <div id="analysis-progress-area"></div>
    </div>

    

    <div id="inputContainer">
         <div id="pendingFilesIndicator" style="font-size: 0.8em; color: var(--secondary-text-color); margin-bottom: 3px; display: none; padding-left: 5px;"></div>
        <textarea id="chatInput" placeholder="Send a message to Stellar..." rows="1"></textarea>
        <div class="input-buttons">
            <div class="left-buttons">
                <label for="fileUpload" class="file-upload-label-button">ğŸ“</label>
                <input type="file" id="fileUpload" multiple style="display: none;">
                <button id="spectrumBtn">Spectrum</button>
                <button id="spectrumSearchBtn">Spectral Search</button>
                <button id="nebulaBtn">Nebula</button>
            </div>
            <div class="right-buttons">
                <select id="modelSelect">
                    <option value="gemini-2.0-flash-lite" title="Fastest model, good for quick answers.">Emerald</option>
                    <option value="gemini-2.0-flash" selected title="Balanced speed and capability. Default.">Lunarity</option>
                    <option value="gemini-2.0-flash-thinking-exp-01-21" title="Smarter, better for complex tasks. Nebula compatible.">Crimson</option>
                    <option value="gemini-2.5-pro-exp-03-25" title="Most powerful model for in-depth analysis. Nebula compatible.">Obsidian</option>
                </select>
                <button id="sendBtn">â¤</button>
            </div>
        </div>
    </div>

    <div id="editModalBackdrop" style="display:none;">
        <div class="modal-content">
            <h2>Edit Research Paper</h2>
            <textarea id="editMarkdownInput" rows="10"></textarea>
            <div class="modal-buttons">
                <button id="cancelEditBtn">Cancel</button>
                <button id="saveEditBtn">Save Changes</button>
            </div>
        </div>
    </div>

    <div id="regenerateModalBackdrop" style="display:none;">
        <div class="modal-content">
            <h2 id="regenerateModalTitle">Regenerate Step Feedback</h2>
            <p style="margin-bottom: 15px; color: var(--secondary-text-color);">Optionally, provide specific instructions for regenerating this step:</p>
            <textarea id="regenerateFeedbackInput" rows="6" placeholder="e.g., Make the explanation simpler, use Python instead of Javascript, add more error handling..."></textarea>
            <div class="modal-buttons">
                <button id="cancelRegenerateBtn">Cancel</button>
                <button id="saveRegenerateBtn">Regenerate with Feedback</button>
                <button id="regenerateWithoutFeedbackBtn">Regenerate Without Feedback</button>
            </div>
        </div>
    </div>

    <span id="modelSelectWidthHelper"></span>

    <script>
        const messagesDiv = document.getElementById("messages");
        const chatInput = document.getElementById("chatInput");
        const sendBtn = document.getElementById("sendBtn");
        const spectrumBtn = document.getElementById("spectrumBtn");
        const spectrumSearchBtn = document.getElementById("spectrumSearchBtn");
        const nebulaBtn = document.getElementById("nebulaBtn");
        const clearHistoryBtn = document.getElementById("clearHistoryBtn");
        const modelSelect = document.getElementById("modelSelect");
        const statusBar = document.getElementById("statusBar");
        const inputContainer = document.getElementById("inputContainer");
        const editModalBackdrop = document.getElementById("editModalBackdrop");
        const editMarkdownInput = document.getElementById("editMarkdownInput");
        const cancelEditBtn = document.getElementById("cancelEditBtn");
        const saveEditBtn = document.getElementById("saveEditBtn");
        const modelSelectWidthHelper = document.getElementById("modelSelectWidthHelper");
        const bodyElement = document.body;
        const regenerateModalBackdrop = document.getElementById("regenerateModalBackdrop");
        const regenerateModalTitle = document.getElementById("regenerateModalTitle");
        const regenerateFeedbackInput = document.getElementById("regenerateFeedbackInput");
        const cancelRegenerateBtn = document.getElementById("cancelRegenerateBtn");
        const saveRegenerateBtn = document.getElementById("saveRegenerateBtn");
        const regenerateWithoutFeedbackBtn = document.getElementById("regenerateWithoutFeedbackBtn");
        const fileUploadInput = document.getElementById("fileUpload");
        const analysisProgressArea = document.getElementById("analysis-progress-area");

        let isResearchMode = false;
        let isNebulaMode = false;
        let currentEditingMsg = null, currentEditingMsgId = null;
        let lastRefinedQuery = "";
        let isProcessing = false;
        let useSpectrumSearch = true;
        let currentStatusText = "Idle";
        let historyLoaded = false;
        let isSpectrumToggleLocked = false;
        let spectrumToggleUnlockTime = 0;
        let currentRegeneratingStep = null;
        let sseEventSource = null;
        let pendingAnalysisFiles = [];

        // Initial definition - this already runs on page load/refresh
        let nebulaProcess = {
            isActive: false,
            processId: null,
            currentStep: 0,
            userQuery: null,
            planOutput: null,
            frontendOutput: null,
            backendOutput: null,
            verificationOutput: null,
            reportUrl: null,
            messageElement: null
        };

        // --- Helper function to explicitly reset Nebula state ---
        function resetNebulaProcessState() {
            console.log("Explicitly resetting Nebula process state on load.");
            nebulaProcess = {
                isActive: false,
                processId: null,
                currentStep: 0,
                userQuery: null,
                planOutput: null,
                frontendOutput: null,
                backendOutput: null,
                verificationOutput: null,
                reportUrl: null,
                messageElement: null
            };
            isNebulaMode = false; // Also ensure Nebula mode itself is off
            if (nebulaBtn) nebulaBtn.classList.remove("active");
            enableDisableModelOptions(false); // Ensure model options are reset
        }
        // --- End of helper function ---


        const NEBULA_COMPATIBLE_MODELS = ["gemini-2.0-flash-thinking-exp-01-21", "gemini-2.5-pro-exp-03-25", "gemini-pro"];
        const DEFAULT_NEBULA_MODEL = "gemini-2.5-pro-exp-03-25";
        const katexDelimiters = [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true }
        ];

        const modelThemes = {
             emerald: { start: '#00c292', end: '#00a77d', border: 'rgba(0, 194, 146, 0.6)', shadow: 'rgba(0, 194, 146, 0.3)', inset: 'rgba(0, 194, 146, 0.2)', h_start: '#00a77d', h_end: '#00c292', h_border: 'rgba(0, 194, 146, 0.8)', h_shadow: 'rgba(0, 194, 146, 0.5)', h_inset: 'rgba(0, 194, 146, 0.3)', h_strong: 'rgba(0, 194, 146, 0.4)', statusBarBg: 'rgba(0, 194, 146, 0.25)', statusBarColor: '#a7f5e3', statusBarShadow: 'rgba(0, 194, 146, 0.4)', titleShadow: 'rgba(0, 100, 80, 0.4)', bodyBg1: '#0a2e26', bodyBg2: '#0f4d3f', bodyBg3: '#146d59', bodyBg4: '#0f4d3f', primaryText: '#e0fdf6', secondaryText: '#94d9c9', headerBg: 'rgba(10, 46, 38, 0.4)', headerBorder: 'rgba(0, 194, 146, 0.2)', inputBg: 'rgba(10, 46, 38, 0.5)', inputBorder: 'rgba(0, 194, 146, 0.15)', inputFocusBg: 'rgba(15, 77, 63, 0.6)', userMsgBg: 'rgba(0, 194, 146, 0.1)', userMsgBorder: 'rgba(0, 194, 146, 0.3)', userMsgHoverBg: 'rgba(0, 194, 146, 0.15)', stellarMsgBg: 'rgba(0, 50, 40, 0.3)', stellarMsgBorder: 'rgba(0, 194, 146, 0.2)', stellarMsgHoverBg: 'rgba(0, 60, 50, 0.4)', nebulaMsgBg: 'rgba(0, 60, 50, 0.35)', nebulaMsgBorder: 'rgba(0, 194, 146, 0.3)', nebulaMsgHoverBg: 'rgba(0, 70, 60, 0.45)', tableBorder: 'rgba(0, 194, 146, 0.4)', codeBg: 'rgba(5, 30, 25, 0.9)', codeBorder: 'rgba(0, 194, 146, 0.5)', codeText: '#e8fff8', inlineCodeText: '#50e3c2', copyBtnBg: 'rgba(0, 194, 146, 0.15)', copyBtnHoverBg: 'rgba(0, 194, 146, 0.25)', copyBtnColor: '#a7f5e3', copyBtnHoverColor: '#e8fff8', copyBtnCopiedBg: '#00a77d', copyBtnCopiedColor: '#ffffff', scrollbarTrack: 'rgba(15, 77, 63, 0.7)', previewBtnBg: 'rgba(0, 194, 146, 0.15)', previewBtnHoverBg: 'rgba(0, 194, 146, 0.25)', previewBtnColor: '#a7f5e3', previewBtnHoverColor: '#e8fff8' },
             lunarity: { start: '#7b61ff', end: '#b554ff', border: 'rgba(181, 84, 255, 0.5)', shadow: 'rgba(123, 97, 255, 0.3)', inset: 'rgba(123, 97, 255, 0.2)', h_start: '#b554ff', h_end: '#7b61ff', h_border: 'rgba(123, 97, 255, 0.7)', h_shadow: 'rgba(123, 97, 255, 0.5)', h_inset: 'rgba(123, 97, 255, 0.3)', h_strong: 'rgba(123, 97, 255, 0.4)', statusBarBg: 'rgba(123, 97, 255, 0.2)', statusBarColor: '#e0d9ff', statusBarShadow: 'rgba(123, 97, 255, 0.4)', titleShadow: 'rgba(123, 97, 255, 0.3)', bodyBg1: '#0f0c29', bodyBg2: '#302b63', bodyBg3: '#24243e', bodyBg4: '#302b63', primaryText: '#f0f0f0', secondaryText: '#a9a3c7', headerBg: 'rgba(20, 16, 50, 0.3)', headerBorder: 'rgba(181, 84, 255, 0.15)', inputBg: 'rgba(20, 16, 50, 0.4)', inputBorder: 'rgba(181, 84, 255, 0.1)', inputFocusBg: 'rgba(30, 26, 60, 0.5)', userMsgBg: 'rgba(123, 97, 255, 0.15)', userMsgBorder: 'rgba(123, 97, 255, 0.3)', userMsgHoverBg: 'rgba(123, 97, 255, 0.2)', stellarMsgBg: 'rgba(0, 0, 0, 0.25)', stellarMsgBorder: 'rgba(123, 97, 255, 0.2)', stellarMsgHoverBg: 'rgba(0, 0, 0, 0.35)', nebulaMsgBg: 'rgba(10, 10, 25, 0.3)', nebulaMsgBorder: 'rgba(123, 97, 255, 0.3)', nebulaMsgHoverBg: 'rgba(15, 15, 35, 0.4)', tableBorder: 'rgba(123, 97, 255, 0.3)', codeBg: 'rgba(10, 10, 25, 0.85)', codeBorder: 'rgba(123, 97, 255, 0.4)', codeText: '#f5f5f5', inlineCodeText: '#cea9ff', copyBtnBg: 'rgba(255, 255, 255, 0.1)', copyBtnHoverBg: 'rgba(255, 255, 255, 0.2)', copyBtnColor: '#c5bfff', copyBtnHoverColor: '#f5f5f5', copyBtnCopiedBg: '#7b61ff', copyBtnCopiedColor: '#ffffff', scrollbarTrack: 'rgba(36, 36, 62, 0.8)', previewBtnBg: 'rgba(255, 255, 255, 0.1)', previewBtnHoverBg: 'rgba(255, 255, 255, 0.2)', previewBtnColor: '#c5bfff', previewBtnHoverColor: '#f5f5f5' },
             crimson: { start: '#D31027', end: '#9A0007', border: 'rgba(211, 16, 39, 0.6)', shadow: 'rgba(211, 16, 39, 0.3)', inset: 'rgba(211, 16, 39, 0.2)', h_start: '#9A0007', h_end: '#D31027', h_border: 'rgba(211, 16, 39, 0.8)', h_shadow: 'rgba(211, 16, 39, 0.5)', h_inset: 'rgba(211, 16, 39, 0.3)', h_strong: 'rgba(211, 16, 39, 0.4)', statusBarBg: 'rgba(211, 16, 39, 0.2)', statusBarColor: '#ffcdd2', statusBarShadow: 'rgba(211, 16, 39, 0.4)', titleShadow: 'rgba(100, 0, 0, 0.4)', bodyBg1: '#2b0404', bodyBg2: '#4d0a0a', bodyBg3: '#6f1010', bodyBg4: '#4d0a0a', primaryText: '#ffebee', secondaryText: '#f7c4c4', headerBg: 'rgba(43, 4, 4, 0.4)', headerBorder: 'rgba(211, 16, 39, 0.2)', inputBg: 'rgba(43, 4, 4, 0.5)', inputBorder: 'rgba(211, 16, 39, 0.15)', inputFocusBg: 'rgba(77, 10, 10, 0.6)', userMsgBg: 'rgba(211, 16, 39, 0.1)', userMsgBorder: 'rgba(211, 16, 39, 0.3)', userMsgHoverBg: 'rgba(211, 16, 39, 0.15)', stellarMsgBg: 'rgba(50, 0, 0, 0.3)', stellarMsgBorder: 'rgba(211, 16, 39, 0.2)', stellarMsgHoverBg: 'rgba(60, 0, 0, 0.4)', nebulaMsgBg: 'rgba(60, 5, 5, 0.35)', nebulaMsgBorder: 'rgba(211, 16, 39, 0.3)', nebulaMsgHoverBg: 'rgba(70, 10, 10, 0.45)', tableBorder: 'rgba(211, 16, 39, 0.4)', codeBg: 'rgba(40, 5, 5, 0.9)', codeBorder: 'rgba(211, 16, 39, 0.5)', codeText: '#ffebee', inlineCodeText: '#ff8a80', copyBtnBg: 'rgba(211, 16, 39, 0.15)', copyBtnHoverBg: 'rgba(211, 16, 39, 0.25)', copyBtnColor: '#ffcdd2', copyBtnHoverColor: '#ffebee', copyBtnCopiedBg: '#9A0007', copyBtnCopiedColor: '#ffffff', scrollbarTrack: 'rgba(77, 10, 10, 0.7)', previewBtnBg: 'rgba(211, 16, 39, 0.15)', previewBtnHoverBg: 'rgba(211, 16, 39, 0.25)', previewBtnColor: '#ffcdd2', previewBtnHoverColor: '#ffebee' },
             obsidian: { start: '#485563', end: '#29323c', border: 'rgba(72, 85, 99, 0.6)', shadow: 'rgba(72, 85, 99, 0.4)', inset: 'rgba(72, 85, 99, 0.2)', h_start: '#29323c', h_end: '#485563', h_border: 'rgba(72, 85, 99, 0.8)', h_shadow: 'rgba(72, 85, 99, 0.6)', h_inset: 'rgba(72, 85, 99, 0.3)', h_strong: 'rgba(72, 85, 99, 0.5)', statusBarBg: 'rgba(72, 85, 99, 0.3)', statusBarColor: '#cfd8dc', statusBarShadow: 'rgba(72, 85, 99, 0.4)', titleShadow: 'rgba(0, 0, 0, 0.4)', bodyBg1: '#0a0c0f', bodyBg2: '#11181f', bodyBg3: '#1a242f', bodyBg4: '#11181f', primaryText: '#eceff1', secondaryText: '#b0bec5', headerBg: 'rgba(26, 32, 39, 0.4)', headerBorder: 'rgba(72, 85, 99, 0.2)', inputBg: 'rgba(26, 32, 39, 0.5)', inputBorder: 'rgba(72, 85, 99, 0.15)', inputFocusBg: 'rgba(44, 62, 80, 0.6)', userMsgBg: 'rgba(72, 85, 99, 0.1)', userMsgBorder: 'rgba(72, 85, 99, 0.3)', userMsgHoverBg: 'rgba(72, 85, 99, 0.15)', stellarMsgBg: 'rgba(20, 30, 40, 0.3)', stellarMsgBorder: 'rgba(72, 85, 99, 0.2)', stellarMsgHoverBg: 'rgba(30, 40, 50, 0.4)', nebulaMsgBg: 'rgba(30, 40, 50, 0.35)', nebulaMsgBorder: 'rgba(72, 85, 99, 0.3)', nebulaMsgHoverBg: 'rgba(40, 50, 60, 0.45)', tableBorder: 'rgba(72, 85, 99, 0.4)', codeBg: 'rgba(15, 22, 30, 1)', codeBorder: 'rgba(72, 85, 99, 0.6)', codeText: '#eceff1', inlineCodeText: '#cfd8dc', copyBtnBg: 'rgba(72, 85, 99, 0.2)', copyBtnHoverBg: 'rgba(72, 85, 99, 0.3)', copyBtnColor: '#b0bec5', copyBtnHoverColor: '#eceff1', copyBtnCopiedBg: '#29323c', copyBtnCopiedColor: '#ffffff', scrollbarTrack: 'rgba(44, 62, 80, 0.7)', previewBtnBg: 'rgba(72, 85, 99, 0.2)', previewBtnHoverBg: 'rgba(72, 85, 99, 0.3)', previewBtnColor: '#b0bec5', previewBtnHoverColor: '#eceff1' },
             'gemini pro': { start: '#7b61ff', end: '#b554ff', border: 'rgba(181, 84, 255, 0.5)', shadow: 'rgba(123, 97, 255, 0.3)', inset: 'rgba(123, 97, 255, 0.2)', h_start: '#b554ff', h_end: '#7b61ff', h_border: 'rgba(123, 97, 255, 0.7)', h_shadow: 'rgba(123, 97, 255, 0.5)', h_inset: 'rgba(123, 97, 255, 0.3)', h_strong: 'rgba(123, 97, 255, 0.4)', statusBarBg: 'rgba(123, 97, 255, 0.2)', statusBarColor: '#e0d9ff', statusBarShadow: 'rgba(123, 97, 255, 0.4)', titleShadow: 'rgba(123, 97, 255, 0.3)', bodyBg1: '#0f0c29', bodyBg2: '#302b63', bodyBg3: '#24243e', bodyBg4: '#302b63', primaryText: '#f0f0f0', secondaryText: '#a9a3c7', headerBg: 'rgba(20, 16, 50, 0.3)', headerBorder: 'rgba(181, 84, 255, 0.15)', inputBg: 'rgba(20, 16, 50, 0.4)', inputBorder: 'rgba(181, 84, 255, 0.1)', inputFocusBg: 'rgba(30, 26, 60, 0.5)', userMsgBg: 'rgba(123, 97, 255, 0.15)', userMsgBorder: 'rgba(123, 97, 255, 0.3)', userMsgHoverBg: 'rgba(123, 97, 255, 0.2)', stellarMsgBg: 'rgba(0, 0, 0, 0.25)', stellarMsgBorder: 'rgba(123, 97, 255, 0.2)', stellarMsgHoverBg: 'rgba(0, 0, 0, 0.35)', nebulaMsgBg: 'rgba(10, 10, 25, 0.3)', nebulaMsgBorder: 'rgba(123, 97, 255, 0.3)', nebulaMsgHoverBg: 'rgba(15, 15, 35, 0.4)', tableBorder: 'rgba(123, 97, 255, 0.3)', codeBg: 'rgba(10, 10, 25, 0.85)', codeBorder: 'rgba(123, 97, 255, 0.4)', codeText: '#f5f5f5', inlineCodeText: '#cea9ff', copyBtnBg: 'rgba(255, 255, 255, 0.1)', copyBtnHoverBg: 'rgba(255, 255, 255, 0.2)', copyBtnColor: '#c5bfff', copyBtnHoverColor: '#f5f5f5', copyBtnCopiedBg: '#7b61ff', copyBtnCopiedColor: '#ffffff', scrollbarTrack: 'rgba(36, 36, 62, 0.8)', previewBtnBg: 'rgba(255, 255, 255, 0.1)', previewBtnHoverBg: 'rgba(255, 255, 255, 0.2)', previewBtnColor: '#c5bfff', previewBtnHoverColor: '#f5f5f5' }
        };

        if (typeof hljs !== 'undefined') {
            hljs.configure({ ignoreUnescapedHTML: true });
        } else {
            console.error("highlight.js not loaded!");
        }
        const turndownService = new TurndownService({
            headingStyle: 'atx',
            hr: '---',
            bulletListMarker: '*',
            codeBlockStyle: 'fenced',
            emDelimiter: '_',
            strongDelimiter: '**',
            linkStyle: 'inlined'
        });
        turndownService.keep(['table', 'thead', 'tbody', 'tr', 'th', 'td']);

        function scrollToBottom() {
            if (messagesDiv && messagesDiv.scrollHeight > messagesDiv.clientHeight) {
                requestAnimationFrame(() => { messagesDiv.scrollTop = messagesDiv.scrollHeight; });
                setTimeout(() => { if (messagesDiv) { messagesDiv.scrollTop = messagesDiv.scrollHeight; } }, 250);
            } else if (messagesDiv) {
                setTimeout(() => { if (messagesDiv) { messagesDiv.scrollTop = messagesDiv.scrollHeight; } }, 300);
            }
        }
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }
        function wrapTables(htmlContent) {
            if (typeof htmlContent !== 'string' || !htmlContent.includes("<table")) return htmlContent;
            try {
                const tempDiv = document.createElement("div");
                tempDiv.innerHTML = htmlContent;
                tempDiv.querySelectorAll("table").forEach(table => {
                    if (!table.parentElement || !table.parentElement.classList.contains('table-wrapper')) {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'table-wrapper';
                        table.parentNode.insertBefore(wrapper, table);
                        wrapper.appendChild(table);
                    }
                });
                return tempDiv.innerHTML;
            } catch (e) {
                console.error("Error wrapping tables:", e);
                return htmlContent;
            }
        }
        function processCodeBlocks(containerElement) {
            if (typeof hljs === 'undefined' || !containerElement) return;
            containerElement.querySelectorAll('pre').forEach(pre => {
                let wrapperDiv = pre.parentElement.classList.contains('code-content-original') ? pre.parentElement : null;
                if (!wrapperDiv) {
                    wrapperDiv = document.createElement('div');
                    wrapperDiv.className = 'code-content-original';
                    pre.parentNode.insertBefore(wrapperDiv, pre);
                    wrapperDiv.appendChild(pre);
                }
                wrapperDiv.querySelectorAll('.code-block-btn').forEach(btn => btn.remove());
                const codeEl = pre.querySelector('code');
                if (!codeEl) return;
                const rawCode = codeEl.textContent || "";
                const escapedCode = escapeHtml(rawCode);
                codeEl.innerHTML = escapedCode;
                codeEl.removeAttribute('data-highlighted');
                codeEl.className = codeEl.className.replace(/hljs.*/g, '').trim();
                const copyBtn = document.createElement('button');
                copyBtn.className = 'code-block-btn copy-code-btn';
                copyBtn.textContent = 'Copy';
                copyBtn.setAttribute('aria-label', 'Copy code to clipboard');
                copyBtn.addEventListener('click', (e) => { e.stopPropagation(); copyCode(copyBtn, rawCode); });
                wrapperDiv.appendChild(copyBtn);
                const langClass = codeEl.className.match(/language-(\w+)/);
                const lang = langClass ? langClass[1] : null;
                const isHtmlLike = lang === 'html' || lang === 'javascript' || lang === 'css' || rawCode.trim().toLowerCase().startsWith('<!doctype html>');
                if (isHtmlLike) {
                    const previewBtn = document.createElement('button');
                    previewBtn.className = 'code-block-btn preview-code-btn';
                    previewBtn.textContent = 'Preview';
                    previewBtn.setAttribute('aria-label', 'Preview code inline');
                    previewBtn.addEventListener('click', (e) => { e.stopPropagation(); previewCode(rawCode, previewBtn); });
                    wrapperDiv.appendChild(previewBtn);
                }
                try {
                    hljs.highlightElement(codeEl);
                } catch (err) {
                    console.error("Highlighting error:", err, codeEl);
                    codeEl.textContent = `// Error highlighting code: ${err.message}\n\n${rawCode}`;
                }
            });
        }
        function copyCode(button, codeToCopy) {
            navigator.clipboard.writeText(codeToCopy).then(() => {
                button.textContent = 'Copied!';
                button.classList.add('copied');
                button.disabled = true;
                setTimeout(() => {
                    button.textContent = 'Copy';
                    button.classList.remove('copied');
                    button.disabled = false;
                }, 1500);
            }).catch(err => {
                console.error('Failed to copy code: ', err);
                button.textContent = 'Error';
                setTimeout(() => { button.textContent = 'Copy'; button.disabled = false; }, 1500);
            });
        }
        function previewCode(codeToPreview, button) {
            const wrapperDiv = button.closest('.code-content-original');
            if (!wrapperDiv) {
                console.error("Could not find parent wrapper (.code-content-original) for preview button.");
                setStatus("Preview Error: Couldn't find code block container.", true);
                setTimeout(() => setStatus(currentStatusText, false), 2500);
                return;
            }
            const preElement = wrapperDiv.querySelector('pre');
            const existingPreviewFrame = wrapperDiv.querySelector('.code-preview-iframe');
            if (!preElement) {
                console.error("Could not find <pre> element inside the wrapper div.");
                setStatus("Preview Error: Code block structure incorrect.", true);
                setTimeout(() => setStatus(currentStatusText, false), 2500);
                return;
            }
            if (existingPreviewFrame) {
                console.log("Toggling back to code view.");
                existingPreviewFrame.remove();
                preElement.style.display = 'block';
                button.textContent = 'Preview';
                button.setAttribute('aria-label', 'Preview code inline');
                const copyBtn = wrapperDiv.querySelector('.copy-code-btn');
                if (copyBtn) copyBtn.style.display = 'inline-block';
            } else {
                console.log("Toggling to preview view.");
                const iframe = document.createElement('iframe');
                iframe.className = 'code-preview-iframe';
                iframe.style.width = '100%';
                iframe.style.height = '400px';
                iframe.style.border = '1px solid var(--code-border)';
                iframe.style.borderRadius = '4px';
                iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin allow-forms');
                try {
                    iframe.srcdoc = codeToPreview;
                } catch (e) {
                    console.error("Error setting iframe srcdoc:", e);
                    iframe.srcdoc = `<html><body><p style='color:red; font-family: sans-serif;'>Error displaying preview: ${escapeHtml(e.message)}</p><hr><pre>${escapeHtml(codeToPreview)}</pre></body></html>`;
                    setStatus("Preview Error: Could not display code.", true);
                    setTimeout(() => setStatus(currentStatusText, false), 3500);
                }
                preElement.style.display = 'none';
                preElement.insertAdjacentElement('afterend', iframe);
                button.textContent = 'Show Code';
                button.setAttribute('aria-label', 'Show original code');
                const copyBtn = wrapperDiv.querySelector('.copy-code-btn');
                if (copyBtn) copyBtn.style.display = 'none';
                setStatus("Preview displayed inline.");
                setTimeout(() => setStatus(currentStatusText, false), 2000);
            }
        }
        function renderMath(element) {
            if (!element || typeof renderMathInElement !== 'function') {
                if (!element) console.warn("renderMath called with no element.");
                else console.warn("KaTeX auto-render function not available.");
                return;
            }
            try {
                renderMathInElement(element, {
                    delimiters: katexDelimiters,
                    throwOnError: false
                });
            } catch (katexError) {
                console.error("KaTeX rendering error:", katexError);
            }
        }

        function appendUserMessage(text, id) {
            const msg = document.createElement("div");
            msg.classList.add("message", "user-msg");
            msg.dataset.id = id;
            const contentDiv = document.createElement("div");
            contentDiv.classList.add("message-content");
            contentDiv.textContent = text;
            msg.appendChild(contentDiv);
            if (messagesDiv) messagesDiv.appendChild(msg);
            scrollToBottom();
        }
        function appendStellarMessage(markdownText, id) {
            const msg = document.createElement("div");
            msg.classList.add("message", "stellar-msg");
            msg.dataset.id = id;
            const contentDiv = document.createElement("div");
            contentDiv.classList.add("message-content");
            try {
                let htmlContent = marked.parse(markdownText || "");
                htmlContent = wrapTables(htmlContent);
                contentDiv.innerHTML = htmlContent;
                processCodeBlocks(contentDiv);
                setTimeout(() => {
                    renderMath(contentDiv);
                    scrollToBottom();
                }, 200);
            } catch (e) {
                console.error("MD Parse Error (Stellar):", e);
                contentDiv.textContent = "Error displaying content.";
                scrollToBottom();
            }
            msg.appendChild(contentDiv);
            if (messagesDiv) messagesDiv.appendChild(msg);
        }
        function appendResearchOutput(markdownText, id) {
            const msg = document.createElement("div");
            msg.classList.add("message", "stellar-msg", "research-output");
            msg.dataset.id = id;
            const contentDiv = document.createElement("div");
            contentDiv.classList.add("message-content");
            let htmlText = "";

            try {
                htmlText = marked.parse(markdownText || "");
                htmlText = wrapTables(htmlText);
                contentDiv.innerHTML = htmlText;
                msg.appendChild(contentDiv);
                processCodeBlocks(contentDiv);
                renderMath(contentDiv);
                createAndAppendResearchButtons(msg, id, contentDiv.innerHTML);
                setTimeout(scrollToBottom, 200);
            } catch (e) {
                console.error("MD Parse Error (Research):", e);
                contentDiv.textContent = "Error displaying research output.";
                htmlText = "<p>Error displaying research output.</p>";
                msg.appendChild(contentDiv);
                createAndAppendResearchButtons(msg, id, htmlText);
                scrollToBottom();
            }
            if (messagesDiv) messagesDiv.appendChild(msg);
        }

        function createAndAppendResearchButtons(msgContainer, messageId, initialHtmlContent) {
            const existingButtonsDiv = msgContainer.querySelector('.message-buttons');
            if (existingButtonsDiv) msgContainer.removeChild(existingButtonsDiv);

            const buttonsDiv = document.createElement('div');
            buttonsDiv.classList.add('message-buttons');

            const editButton = document.createElement("button");
            editButton.textContent = "Edit";
            editButton.classList.add("edit-paper-btn");
            editButton.addEventListener("click", function () {
                const msgDiv = this.closest('.message.research-output');
                if (msgDiv) {
                    const currentHTML = msgDiv.querySelector('.message-content').innerHTML;
                    const id = msgDiv.dataset.id;
                    showEditModal(id, currentHTML, msgDiv);
                } else {
                    console.error("Edit Btn: Cannot find parent message.");
                }
            });

            const downloadButton = document.createElement("button");
            downloadButton.textContent = "Download";
            downloadButton.classList.add("download-btn");
            downloadButton.addEventListener("click", () => {
                const msgDiv = downloadButton.closest('.message.research-output');
                if (msgDiv) {
                    const currentHTML = msgDiv.querySelector('.message-content').innerHTML;
                    const currentWidth = msgDiv.offsetWidth;
                    downloadHtml(currentHTML, currentWidth);
                } else {
                    console.error("Download Btn: Cannot find parent message.");
                }
            });

            buttonsDiv.appendChild(editButton);
            buttonsDiv.appendChild(downloadButton);
            msgContainer.appendChild(buttonsDiv);
        }

        function setStatus(text, isError = false) {
            if (!statusBar) return;
            currentStatusText = text;
            statusBar.textContent = text;
            const hasPending = pendingAnalysisFiles.length > 0;
            const analysisAreaHasContent = document.getElementById('analysis-progress-area')?.childElementCount > 0;
            const isActive = text.toLowerCase() !== "idle" || isProcessing || (nebulaProcess.isActive && !isProcessing) || analysisAreaHasContent || hasPending;
            statusBar.classList.toggle("active", isActive && !isError);
            statusBar.classList.toggle("error", isError);
            if (isActive && !isError) {
                statusBar.style.animation = '';
                statusBar.offsetWidth; // Trigger reflow
                statusBar.style.animation = 'statusBarPulse 2.5s infinite alternate ease-in-out';
            } else {
                statusBar.style.animation = '';
            }
            updateStatusBarPosition();
        }


        function updateStatusBarPosition() {
            if (!inputContainer || !statusBar) return;
            try {
                const inputRect = inputContainer.getBoundingClientRect();
                 const progressArea = document.getElementById('analysis-progress-area');
                 const progressAreaHeight = (progressArea && progressArea.offsetHeight > 0 && progressArea.style.display !== 'none') ? progressArea.offsetHeight : 0;
                 const pendingIndicator = document.getElementById('pendingFilesIndicator');
                 const indicatorHeight = (pendingIndicator && pendingIndicator.offsetHeight > 0 && pendingIndicator.style.display !== 'none') ? pendingIndicator.offsetHeight + 3 : 0; // +3 for margin
                 const extraGap = (progressAreaHeight > 0 || indicatorHeight > 0) ? 10 : 0; // Add gap if elements are visible above input
                 statusBar.style.bottom = `${window.innerHeight - inputRect.top + 5 + progressAreaHeight + indicatorHeight + extraGap}px`;
            } catch (e) {
                console.error("Error updating status bar position:", e);
                 // Fallback position calculation
                 const inputRect = inputContainer.getBoundingClientRect();
                 statusBar.style.bottom = `${window.innerHeight - inputRect.top + 5}px`;
            }
        }

        function adjustTextareaHeight() {
            if (!chatInput) return;
            try {
                chatInput.style.height = "auto";
                const newHeight = Math.min(chatInput.scrollHeight, 240); // Max height 240px
                chatInput.style.height = `${newHeight}px`;
                chatInput.style.overflowY = newHeight >= 240 ? "auto" : "hidden";
                updateStatusBarPosition(); // Update status bar position after textarea resize
            } catch (e) {
                console.error("Error adjusting textarea height:", e);
            }
        }
        function showEditModal(id, htmlContent, msgDiv) {
            currentEditingMsg = msgDiv;
            currentEditingMsgId = id;
            try {
                editMarkdownInput.value = turndownService.turndown(htmlContent || "");
            } catch (e) {
                console.error("Turndown error:", e);
                editMarkdownInput.value = "Error converting HTML to Markdown.";
            }
            if (editModalBackdrop) editModalBackdrop.style.display = "flex";
            if (editMarkdownInput) setTimeout(() => editMarkdownInput.focus(), 100); // Focus after slight delay
        }
        function hideEditModal() {
            if (editModalBackdrop) editModalBackdrop.style.display = "none";
            currentEditingMsg = null;
            currentEditingMsgId = null;
            if (editMarkdownInput) editMarkdownInput.value = "";
        }
        function showRegenerateModal(stepNumber) {
            if (!nebulaProcess.isActive) return;
            currentRegeneratingStep = stepNumber;
            regenerateModalTitle.textContent = `Regenerate Step ${stepNumber}: ${getNebulaStepTitle(stepNumber)}`;
            regenerateFeedbackInput.value = ""; // Clear previous feedback
            if (regenerateModalBackdrop) regenerateModalBackdrop.style.display = "flex";
            if (regenerateFeedbackInput) setTimeout(() => regenerateFeedbackInput.focus(), 100);
        }
        function hideRegenerateModal() {
            if (regenerateModalBackdrop) regenerateModalBackdrop.style.display = "none";
            regenerateFeedbackInput.value = "";
            currentRegeneratingStep = null;
            // Re-enable buttons if Nebula is waiting for confirmation
            if (nebulaProcess.isActive && !isProcessing) {
                updateNebulaButtonStates();
            }
        }

        function triggerRegeneration(stepToRegenerate, feedback = null) {
    if (stepToRegenerate === null || !nebulaProcess.isActive || isProcessing) {
        console.error("Invalid state for triggering regeneration.");
        setStatus("Cannot regenerate now.", true);
        setTimeout(() => setStatus(currentStatusText, false), 2500);
        hideRegenerateModal();
        return;
    }
    setStatus(`Nebula: Preparing regeneration for ${getNebulaStepTitle(stepToRegenerate)}...`);
    isProcessing = true;
    sendBtn.disabled = true;
    disableAllNebulaStepActions();

    if (stepToRegenerate <= nebulaProcess.currentStep) {
        console.log(`Regenerating Step ${stepToRegenerate}, rolling back from Step ${nebulaProcess.currentStep}.`);
        const stepsContainer = nebulaProcess.messageElement?.querySelector('.nebula-steps-container');
        if (stepsContainer) {
            for (let i = stepToRegenerate + 1; i <= 4; i++) {
                const stepDiv = stepsContainer.querySelector(`.nebula-step-content[data-step="${i}"]`);
                if (stepDiv) stepDiv.remove();
            }
        }

        if (stepToRegenerate < 2) nebulaProcess.frontendOutput = null;
        if (stepToRegenerate < 3) nebulaProcess.backendOutput = null;
        if (stepToRegenerate < 4) nebulaProcess.verificationOutput = null;
        nebulaProcess.reportUrl = null;
        nebulaProcess.currentStep = stepToRegenerate;
        console.log(`Rolled back. Current step is now: ${nebulaProcess.currentStep}`);
    } else {
         console.log(`Regenerating future step ${stepToRegenerate}. No rollback needed. This shouldn't typically happen via UI.`);
    }

    const currentStepOutputDiv = nebulaProcess.messageElement?.querySelector(`.nebula-step-content[data-step="${stepToRegenerate}"] .step-output`);
    if (currentStepOutputDiv) {
         currentStepOutputDiv.innerHTML = `<i>Regenerating...</i>`;
    } else {
         // If the step div was removed by rollback, we need to recreate a placeholder.
         // Note: displayNebulaStepOutput is typically called by the response handler,
         // but we might need a temporary visual cue here if the div is gone.
         // For simplicity, we'll rely on the status bar and let the response handler redraw.
         console.log(`Step ${stepToRegenerate} content area not found (likely rolled back), waiting for response to redraw.`);
    }

    requestNebulaStep(stepToRegenerate, true, feedback);
    hideRegenerateModal();
}

        function handleSaveRegeneration() {
            const feedback = regenerateFeedbackInput.value.trim();
            triggerRegeneration(currentRegeneratingStep, feedback);
        }

        function updateNebulaButtonStates() {
    console.log(`Updating Nebula button states. Current Step: ${nebulaProcess.currentStep}, Is Processing: ${isProcessing}`);
    if (!nebulaProcess.messageElement || !nebulaProcess.isActive) {
        console.log("Nebula not active or message element missing, disabling all.");
        disableAllNebulaStepActions();
        return;
    }
    const stepsContainer = nebulaProcess.messageElement.querySelector('.nebula-steps-container');
    if (!stepsContainer) return;

    for (let i = 1; i <= 4; i++) { // Check all steps 1-4
        const actionsDiv = stepsContainer.querySelector(`.nebula-step-actions[data-step="${i}"]`);
        const stepOutputDiv = stepsContainer.querySelector(`.nebula-step-content[data-step="${i}"]`);

        if (!actionsDiv && i <= 3) continue; // No actions div for steps 1-3 means nothing to update
        if (!stepOutputDiv) continue; // No content div means step hasn't been generated

        const confirmBtn = actionsDiv?.querySelector('.nebula-confirm-btn'); // Actions only exist for 1-3
        const regenerateBtn = actionsDiv?.querySelector('.nebula-regenerate-btn'); // Actions only exist for 1-3

        let stepOutputExists = false;
        switch (i) {
            case 1: stepOutputExists = !!nebulaProcess.planOutput; break;
            case 2: stepOutputExists = !!nebulaProcess.frontendOutput; break;
            case 3: stepOutputExists = !!nebulaProcess.backendOutput; break;
            case 4: stepOutputExists = !!nebulaProcess.verificationOutput; break; // Check step 4 output for completeness
        }

        // Enable Regenerate button (for steps 1-3) if:
        // 1. Output for THIS step exists.
        // 2. Nebula is active.
        // 3. Not currently processing.
        const enableRegenerate = stepOutputExists && nebulaProcess.isActive && !isProcessing && i <= 3;
        if (regenerateBtn) regenerateBtn.disabled = !enableRegenerate;

        // Enable Confirm button ONLY if:
        // 1. This is the CURRENT step Nebula is waiting on.
        // 2. Output for this step exists.
        // 3. Nebula is active.
        // 4. Not currently processing.
        const enableConfirm = (i === nebulaProcess.currentStep) && stepOutputExists && nebulaProcess.isActive && !isProcessing && i <= 3;
        if (confirmBtn) confirmBtn.disabled = !enableConfirm;
    }
    console.log("Nebula button states updated.");
}

        function disableAllNebulaStepActions() {
            console.log("Disabling all Nebula step actions.");
            if (!nebulaProcess.messageElement) return;
            const allConfirmBtns = nebulaProcess.messageElement.querySelectorAll('.nebula-confirm-btn');
            const allRegenerateBtns = nebulaProcess.messageElement.querySelectorAll('.nebula-regenerate-btn');
            allConfirmBtns.forEach(btn => btn.disabled = true);
            allRegenerateBtns.forEach(btn => btn.disabled = true);
        }

        function updateSpectrumSearchButtonState(isOn) {
            useSpectrumSearch = isOn;
            if (spectrumSearchBtn) {
                spectrumSearchBtn.classList.toggle("on", isOn);
            }
        }
        function deactivateAllModes(except = null) {
            console.log(`Deactivating modes, except: ${except}`);
            // Deactivate Spectrum Mode
            if (isResearchMode && except !== 'spectrum') {
                spectrumBtn?.classList.remove("active");
                if (spectrumSearchBtn) {
                    spectrumSearchBtn.style.display = "none";
                    spectrumSearchBtn.disabled = true; // Ensure it's disabled
                    spectrumSearchBtn.classList.remove("on"); // Ensure 'on' state is removed
                }
                isResearchMode = false;
                useSpectrumSearch = false; // Reset search preference
                console.log("Spectrum mode deactivated.");
            }
            // Deactivate Nebula Mode
            if (isNebulaMode && except !== 'nebula') {
                 if (nebulaProcess.isActive) {
                     // Attempt to gracefully clean up if a process was active
                     cleanupNebulaProcess(true, "Nebula process aborted due to mode change.");
                 }
                nebulaBtn?.classList.remove("active");
                isNebulaMode = false;
                enableDisableModelOptions(false); // Re-enable all model options
                console.log("Nebula mode deactivated.");
            }

            // Update placeholder text based on active mode (or none)
            if (!isResearchMode && !isNebulaMode) {
                chatInput.placeholder = "Send a message to Stellar...";
                chatInput.classList.remove("research-mode", "nebula-mode");
            } else if (isResearchMode) {
                chatInput.placeholder = "Enter research query for Spectrum...";
                chatInput.classList.remove("nebula-mode"); // Ensure nebula class is removed
                chatInput.classList.add("research-mode");
            } else if (isNebulaMode) {
                chatInput.placeholder = "Describe the application/code you want Nebula to generate...";
                chatInput.classList.remove("research-mode"); // Ensure research class is removed
                chatInput.classList.add("nebula-mode");
            }
        }
        function toggleSpectrumMode() {
            const now = Date.now();
            // Check for cooldown lock
            if (!isResearchMode && isSpectrumToggleLocked && now < spectrumToggleUnlockTime) {
                const remainingSeconds = Math.ceil((spectrumToggleUnlockTime - now) / 1000);
                setStatus(`Please wait ${remainingSeconds}s to toggle Spectrum mode.`, true);
                setTimeout(() => {
                    // Re-check lock after delay before clearing status
                    const stillLocked = isSpectrumToggleLocked && Date.now() < spectrumToggleUnlockTime;
                    setStatus(stillLocked ? `Please wait ${Math.ceil((spectrumToggleUnlockTime - Date.now()) / 1000)}s...` : currentStatusText, stillLocked);
                }, 1500);
                return; // Prevent toggling
            }
            // Unlock if cooldown passed
            if (isSpectrumToggleLocked && now >= spectrumToggleUnlockTime) {
                isSpectrumToggleLocked = false;
                console.log("Spectrum toggle unlocked.");
                // Only set status to Idle if nothing else is running
                if (!isProcessing && !nebulaProcess.isActive && pendingAnalysisFiles.length === 0) setStatus("Idle");
            }

            if (!isResearchMode) { // Activate Spectrum
                // Check if Nebula is active and blocking
                if (isNebulaMode && nebulaProcess.isActive) {
                    setStatus(`Cannot activate Spectrum while Nebula process is active.`, true);
                    setTimeout(() => setStatus(currentStatusText, false), 2500);
                    return; // Prevent activation
                }
                deactivateAllModes('spectrum'); // Deactivate other modes first
                isResearchMode = true;
                spectrumBtn.classList.add("active");
                spectrumSearchBtn.style.display = "inline-block"; // Show search toggle
                spectrumSearchBtn.disabled = false; // Enable search toggle
                updateSpectrumSearchButtonState(true); // Default to search ON
                console.log("Spectrum mode activated.");
            } else { // Deactivate Spectrum
                deactivateAllModes();
                console.log("Spectrum mode deactivated by toggle.");
            }
            chatInput.focus(); // Focus input after mode change
            adjustTextareaHeight(); // Adjust height if needed
        }
        function toggleNebulaMode() {
            // Prevent deactivation if Nebula is active and waiting/processing
            if (isNebulaMode && nebulaProcess.isActive && !isProcessing) {
                setStatus(`Cannot deactivate Nebula while waiting for confirmation on Step ${nebulaProcess.currentStep}.`, true);
                setTimeout(() => setStatus(currentStatusText, false), 2500);
                return;
            }
            if (isNebulaMode && isProcessing) { // Check isProcessing specifically for Nebula context if needed
                setStatus(`Cannot deactivate Nebula while Step ${nebulaProcess.currentStep} is being processed.`, true);
                setTimeout(() => setStatus(currentStatusText, false), 2500);
                return;
            }

            if (!isNebulaMode) { // Activate Nebula
                // Check if Spectrum is active and blocking
                if (isResearchMode) {
                    setStatus(`Please deactivate Spectrum mode first.`, true);
                    setTimeout(() => setStatus(currentStatusText), 2500); // Restore status after msg
                    return; // Prevent activation
                }
                deactivateAllModes('nebula'); // Deactivate other modes first
                isNebulaMode = true;
                nebulaBtn.classList.add("active");
                enableDisableModelOptions(true); // Filter models for Nebula compatibility
                console.log("Nebula mode activated.");
            } else { // Deactivate Nebula
                deactivateAllModes();
                console.log("Nebula mode deactivated by toggle.");
            }
            chatInput.focus(); // Focus input after mode change
            adjustTextareaHeight(); // Adjust height if needed
        }
        function enableDisableModelOptions(filterForNebula) {
            let currentModelSelected = modelSelect.value;
            let validModelFound = false;
            let firstValidNebulaModel = null;
            console.log(`Filtering models for Nebula: ${filterForNebula}. Current: ${currentModelSelected}`);

            for (const option of modelSelect.options) {
                const isCompatible = NEBULA_COMPATIBLE_MODELS.includes(option.value);
                if (filterForNebula) {
                    option.disabled = !isCompatible;
                    if (isCompatible) {
                        if (!firstValidNebulaModel) firstValidNebulaModel = option.value;
                        // Check if the currently selected model is compatible
                        if (option.value === currentModelSelected) validModelFound = true;
                    }
                    // Visual cues for disabled options
                    option.style.opacity = isCompatible ? '1' : '0.5';
                    option.style.cursor = isCompatible ? 'pointer' : 'not-allowed';
                } else {
                    // Re-enable all options when Nebula is off
                    option.disabled = false;
                    option.style.opacity = '1';
                    option.style.cursor = 'pointer';
                }
            }

            // If Nebula is activated and the current model isn't compatible, switch to a default/first valid one
            if (filterForNebula && !validModelFound) {
                const switchTo = firstValidNebulaModel || DEFAULT_NEBULA_MODEL; // Fallback to absolute default
                console.warn(`Nebula Mode: Current model ${currentModelSelected} incompatible or disabled. Switching to ${switchTo}.`);
                modelSelect.value = switchTo;
                updateModelSelectWidth(); // Update width for the new selection
                updateModelSelectTheme(); // Update theme for the new selection
            }
        }
        function updateModelSelectWidth() {
            if (!modelSelect || !modelSelectWidthHelper) return;
            const selectedOption = modelSelect.options[modelSelect.selectedIndex];
            if (selectedOption) {
                // Use helper span to measure text width
                modelSelectWidthHelper.textContent = selectedOption.text;
                const textWidth = modelSelectWidthHelper.offsetWidth;
                const padding = 28; // Horizontal padding in the select
                const borderWidth = 2; // Border width
                const buffer = 5; // Extra space
                const newWidth = textWidth + padding + borderWidth + buffer;
                // Set width, ensuring a minimum width
                modelSelect.style.width = `${Math.max(80, newWidth)}px`;
            } else {
                modelSelect.style.width = 'auto'; // Fallback
            }
        }

        function updateModelSelectTheme() {
            if (!modelSelect || !bodyElement) return;
            const selectedOption = modelSelect.options[modelSelect.selectedIndex];
            if (selectedOption) {
                const modelKey = selectedOption.value;
                const themeName = selectedOption.text.toLowerCase(); // e.g., "emerald", "lunarity"
                // Find the theme object, fallback to lunarity if not found
                const theme = modelThemes[modelKey] || modelThemes[themeName] || modelThemes.lunarity;
                const root = document.documentElement; // Get the root element (<html>)

                // Set body class for potential global theme overrides
                bodyElement.className = `theme-${themeName.replace(/\s+/g, '-')}`;

                // Map theme keys to CSS variables
                Object.keys(theme).forEach(key => {
                    let cssVarName;
                    // Handle hover variables (prefixed with h_)
                    if (key.startsWith('h_')) {
                        if (key === 'h_strong') cssVarName = '--model-hover-shadow-strong';
                        else if (key === 'h_inset') cssVarName = '--model-hover-color-shadow-inset';
                        else if (key === 'h_shadow') cssVarName = '--model-hover-color-shadow';
                        else if (key === 'h_border') cssVarName = '--model-hover-color-border';
                        else cssVarName = `--model-hover-color-${key.substring(2).replace('_', '-')}`; // e.g., h_start -> --model-hover-color-start
                    }
                    // Handle base model color variables
                    else if (['start', 'end', 'border', 'shadow', 'inset'].includes(key)) {
                        cssVarName = `--model-color-${key.replace('_', '-')}`; // e.g., start -> --model-color-start
                    }
                    // Handle specific UI element variables with direct mapping
                    else if (key === 'bodyBg1') { cssVarName = '--body-bg-color1'; }
                    else if (key === 'bodyBg2') { cssVarName = '--body-bg-color2'; }
                    else if (key === 'bodyBg3') { cssVarName = '--body-bg-color3'; }
                    else if (key === 'bodyBg4') { cssVarName = '--body-bg-color4'; }
                    else {
                        // Use a switch for remaining specific variables
                        switch (key) {
                            case 'titleShadow': cssVarName = '--title-shadow-color'; break;
                            case 'statusBarBg': cssVarName = '--status-bar-bg'; break;
                            case 'statusBarColor': cssVarName = '--status-bar-color'; break;
                            case 'statusBarShadow': cssVarName = '--status-bar-shadow'; break;
                            case 'primaryText': cssVarName = '--primary-text-color'; break;
                            case 'secondaryText': cssVarName = '--secondary-text-color'; break;
                            case 'headerBg': cssVarName = '--header-bg'; break;
                            case 'headerBorder': cssVarName = '--header-border'; break;
                            case 'inputBg': cssVarName = '--input-bg'; break;
                            case 'inputBorder': cssVarName = '--input-border'; break;
                            case 'inputFocusBg': cssVarName = '--input-focus-bg'; break;
                            case 'userMsgBg': cssVarName = '--user-msg-bg'; break;
                            case 'userMsgBorder': cssVarName = '--user-msg-border'; break;
                            case 'userMsgHoverBg': cssVarName = '--user-msg-hover-bg'; break;
                            case 'stellarMsgBg': cssVarName = '--stellar-msg-bg'; break;
                            case 'stellarMsgBorder': cssVarName = '--stellar-msg-border'; break;
                            case 'stellarMsgHoverBg': cssVarName = '--stellar-msg-hover-bg'; break;
                            case 'nebulaMsgBg': cssVarName = '--nebula-msg-bg'; break;
                            case 'nebulaMsgBorder': cssVarName = '--nebula-msg-border'; break;
                            case 'nebulaMsgHoverBg': cssVarName = '--nebula-msg-hover-bg'; break;
                            case 'tableBorder': cssVarName = '--table-border-color'; break;
                            case 'codeBg': cssVarName = '--code-bg'; break;
                            case 'codeBorder': cssVarName = '--code-border'; break;
                            case 'codeText': cssVarName = '--code-text-color'; break;
                            case 'inlineCodeText': cssVarName = '--inline-code-text-color'; break;
                            case 'copyBtnBg': cssVarName = '--code-btn-bg'; break; // Note: shared variable name
                            case 'copyBtnHoverBg': cssVarName = '--code-btn-hover-bg'; break; // Note: shared variable name
                            case 'copyBtnColor': cssVarName = '--code-btn-color'; break; // Note: shared variable name
                            case 'copyBtnHoverColor': cssVarName = '--code-btn-hover-color'; break; // Note: shared variable name
                            case 'copyBtnCopiedBg': cssVarName = '--copy-btn-copied-bg'; break;
                            case 'copyBtnCopiedColor': cssVarName = '--copy-btn-copied-color'; break;
                            case 'scrollbarTrack': cssVarName = '--scrollbar-track-bg'; break;
                            case 'previewBtnBg': cssVarName = '--preview-btn-bg'; break; // Note: shared variable name
                            case 'previewBtnHoverBg': cssVarName = '--preview-btn-hover-bg'; break; // Note: shared variable name
                            case 'previewBtnColor': cssVarName = '--preview-btn-color'; break; // Note: shared variable name
                            case 'previewBtnHoverColor': cssVarName = '--preview-btn-hover-color'; break; // Note: shared variable name
                            default: cssVarName = null; // Ignore keys not mapped
                        }
                    }
                    // Set the CSS variable on the root element
                    if (cssVarName) {
                        root.style.setProperty(cssVarName, theme[key]);
                    }
                });

                // Set derived/dependent variables
                root.style.setProperty('--link-color', theme.start);
                root.style.setProperty('--link-hover-color', theme.h_start);
                root.style.setProperty('--input-focus-border', theme.border);
                root.style.setProperty('--inline-code-bg', theme.stellarMsgBg || 'rgba(0,0,0, 0.3)'); // Fallback for inline code bg
                root.style.setProperty('--status-bar-idle-color', theme.secondaryText);
                root.style.setProperty('--status-bar-idle-bg', 'rgba(0, 0, 0, 0.2)'); // Standard idle background
                // Scrollbar thumbs
                root.style.setProperty('--scrollbar-thumb-start', theme.start);
                root.style.setProperty('--scrollbar-thumb-end', theme.end);
                root.style.setProperty('--scrollbar-thumb-border', theme.border);
                root.style.setProperty('--scrollbar-thumb-hover-start', theme.h_start);
                root.style.setProperty('--scrollbar-thumb-hover-end', theme.h_end);
                root.style.setProperty('--scrollbar-thumb-hover-border', theme.h_border);

                // Update background glow colors
                const glow1 = document.querySelector('.glow-1');
                const glow2 = document.querySelector('.glow-2');
                if (glow1) glow1.style.background = `radial-gradient(circle, ${theme.start}99 0%, rgba(123, 97, 255, 0) 70%)`; // Use start color, 60% opacity hex
                if (glow2) glow2.style.background = `radial-gradient(circle, ${theme.end}99 0%, rgba(181, 84, 255, 0) 70%)`; // Use end color, 60% opacity hex
            }
        }

        function getNebulaStepTitle(stepNumber) {
            switch (stepNumber) {
                case 1: return "Planning";
                case 2: return "Frontend Code (HTML/CSS/JS)";
                case 3: return "Backend Code (Flask)";
                case 4: return "Verification Report";
                default: return `Step ${stepNumber}`;
            }
        }
        function getNebulaStepActionDescription(stepNumber) {
            switch (stepNumber) {
                case 1: return "Planning";
                case 2: return "Generating Frontend Code";
                case 3: return "Generating Backend Code";
                case 4: return "Generating Verification Report";
                default: return `Processing Step ${stepNumber}`;
            }
        }
        function displayNebulaStepOutput(stepNumber, markdownText) {
            if (!nebulaProcess.messageElement) {
                console.error("Nebula message container not found!");
                return;
            }
            const stepsContainer = nebulaProcess.messageElement.querySelector('.nebula-steps-container');
            if (!stepsContainer) {
                console.error("Nebula steps container not found!");
                return;
            }

            // Find or create the div for this step
            let stepDiv = stepsContainer.querySelector(`.nebula-step-content[data-step="${stepNumber}"]`);
            if (!stepDiv) {
                stepDiv = document.createElement('div');
                stepDiv.classList.add('nebula-step-content');
                stepDiv.dataset.step = stepNumber;
                // Insert in correct order if regenerating
                const existingSteps = Array.from(stepsContainer.querySelectorAll('.nebula-step-content'));
                let inserted = false;
                for (const existingStep of existingSteps) {
                    if (parseInt(existingStep.dataset.step) > stepNumber) {
                        stepsContainer.insertBefore(stepDiv, existingStep);
                        inserted = true;
                        break;
                    }
                }
                if (!inserted) stepsContainer.appendChild(stepDiv);
            } else {
                // Clear existing content if step div already exists (e.g., on regeneration)
                stepDiv.innerHTML = '';
            }

            const stepTitle = getNebulaStepTitle(stepNumber);
            let stepHtml = "";
            try {
                // Use String() to handle potential non-string inputs gracefully
                stepHtml = marked.parse(String(markdownText || `(Waiting for Step ${stepNumber}...)`));
                stepHtml = wrapTables(stepHtml); // Wrap tables
            } catch (parseErr) {
                console.error(`Markdown parse error for step ${stepNumber}:`, parseErr);
                // Display error safely within a pre tag
                stepHtml = `<pre>Error parsing step output: ${parseErr.message}\n\n${escapeHtml(String(markdownText || ''))}</pre>`;
            }

            // Set the inner HTML for the step
            stepDiv.innerHTML = `<h3>${stepTitle}</h3><div class="step-output">${stepHtml}</div>`;

            // Add action buttons (Confirm/Regenerate) for steps 1-3 if they don't exist
            if (stepNumber >= 1 && stepNumber <= 3 && !stepDiv.querySelector('.nebula-step-actions')) {
                const actionsDiv = document.createElement('div');
                actionsDiv.classList.add('nebula-step-actions');
                actionsDiv.dataset.step = stepNumber; // Associate actions with the step

                // Confirm Button
                const confirmBtn = document.createElement('button');
                confirmBtn.textContent = 'Confirm & Continue ğŸ‘';
                confirmBtn.classList.add('nebula-confirm-btn');
                confirmBtn.id = `confirm-btn-step-${stepNumber}`;
                confirmBtn.onclick = () => handleNebulaConfirm(stepNumber);
                confirmBtn.disabled = true; // Initially disabled
                actionsDiv.appendChild(confirmBtn);

                // Regenerate Button
                const regenerateBtn = document.createElement('button');
                regenerateBtn.textContent = 'Regenerate Step ğŸ”„';
                regenerateBtn.classList.add('nebula-regenerate-btn');
                regenerateBtn.id = `regenerate-btn-step-${stepNumber}`;
                regenerateBtn.onclick = () => handleNebulaRegenerate(stepNumber);
                regenerateBtn.disabled = true; // Initially disabled
                actionsDiv.appendChild(regenerateBtn);

                stepDiv.appendChild(actionsDiv);
            }

            // Process code blocks and render math in the newly added content
            const outputDiv = stepDiv.querySelector('.step-output');
            if (outputDiv) {
                processCodeBlocks(outputDiv);
                setTimeout(() => { // Delay math rendering slightly
                    renderMath(outputDiv);
                    scrollToBottom(); // Scroll after rendering
                }, 200);
            } else {
                scrollToBottom(); // Scroll even if no output div (e.g., error message)
            }
        }

        function handleNebulaConfirm(confirmedStepNumber) {
            console.log(`User confirmed Step ${confirmedStepNumber} for process ${nebulaProcess.processId}`);
            // Validate state before proceeding
            if (!nebulaProcess.isActive || isProcessing || nebulaProcess.currentStep !== confirmedStepNumber) {
                console.warn("Confirmation received in invalid state.");
                setStatus("Cannot proceed, process state issue.", true);
                setTimeout(() => setStatus(currentStatusText, false), 2500);
                return;
            }
            disableAllNebulaStepActions(); // Disable buttons while processing next step
            const nextStep = confirmedStepNumber + 1;
            if (nextStep <= 4) { // Proceed to next step if within bounds
                setStatus(`Nebula: Proceeding to ${getNebulaStepActionDescription(nextStep)}...`);
                isProcessing = true; // Set processing flag
                sendBtn.disabled = true; // Disable main send button
                nebulaProcess.currentStep = nextStep; // Update current step
                requestNebulaStep(nextStep); // Request the next step from backend
            } else {
                // Should not happen if UI is correct, but handle defensively
                console.error("Confirmation received for final step, but next step is > 4? Should not happen.");
                cleanupNebulaProcess(true, "Internal error after final step confirmation.");
            }
        }

        function handleNebulaRegenerate(stepToRegenerate) {
            console.log(`User requesting regeneration UI for Step ${stepToRegenerate} (Process ${nebulaProcess.processId})`);
            // Validate state before showing modal
            if (!nebulaProcess.isActive || isProcessing) {
                console.warn("Regeneration UI requested in invalid state (inactive or processing).");
                const errorMsg = isProcessing ? "Cannot regenerate while another step is processing." : "Nebula process is not active.";
                setStatus(errorMsg, true);
                setTimeout(() => setStatus(currentStatusText, false), 2500);
                return;
            }
            // Disable buttons temporarily while modal is shown
            disableAllNebulaStepActions();
            showRegenerateModal(stepToRegenerate); // Show the feedback modal
            setStatus(`Nebula: Awaiting feedback for regenerating ${getNebulaStepTitle(stepToRegenerate)}...`);
        }

        function createNebulaMessageContainer(processId) {
            const msg = document.createElement("div");
            msg.classList.add("message", "stellar-msg", "nebula-output");
            msg.dataset.id = `nebula-output-${processId}`; // Unique ID for the container
            const contentDiv = document.createElement("div");
            contentDiv.classList.add("message-content");
            // Initial structure with status placeholder
            contentDiv.innerHTML = `<h2>Nebula Code Generation <span class="nebula-status">(Initializing...)</span></h2><div class="nebula-steps-container"></div><div class="nebula-final-summary"></div>`;
            msg.appendChild(contentDiv);
            if (messagesDiv) messagesDiv.appendChild(msg);
            scrollToBottom();
            return msg;
        }

        function cleanupNebulaProcess(showErrorStatus = false, errorMessage = null) {
            console.log("Cleaning up Nebula Process. Error:", showErrorStatus, errorMessage);
            const wasActive = nebulaProcess.isActive; // Check if it was active before cleanup
            isProcessing = false; // Ensure processing flag is off
            nebulaProcess.isActive = false; // Mark Nebula as inactive *IMPORTANT*
            if (sendBtn) sendBtn.disabled = false; // Re-enable main send button

            // Set final status bar message
            const finalStatus = showErrorStatus
                ? (errorMessage ? `Nebula Error: ${errorMessage}` : "Nebula Error")
                : (wasActive ? "Nebula: Process Finished" : "Idle"); // Show "Finished" only if it was active
            setStatus(finalStatus, showErrorStatus);

            // Update the Nebula message box status if it exists
            if (nebulaProcess.messageElement) {
                const statusSpan = nebulaProcess.messageElement.querySelector('.nebula-status');
                if (statusSpan) {
                    statusSpan.textContent = showErrorStatus ? `(Error: ${errorMessage || 'Failed'})` : `(Finished)`;
                }
                // Add visual indicator for error state
                if (showErrorStatus) {
                    nebulaProcess.messageElement.style.borderColor = 'red';
                    nebulaProcess.messageElement.style.borderWidth = '2px';
                }
                disableAllNebulaStepActions(); // Ensure buttons are disabled on finish/error
            }

            // Reset the nebulaProcess object completely *IMPORTANT*
            nebulaProcess = { isActive: false, processId: null, currentStep: 0, userQuery: null, planOutput: null, frontendOutput: null, backendOutput: null, verificationOutput: null, reportUrl: null, messageElement: null };

            // Set timeout to potentially clear error status if nothing else is running
            if (showErrorStatus) {
                setTimeout(() => {
                    // Check if truly idle after the error message timeout
                    if (!isProcessing && !nebulaProcess.isActive && pendingAnalysisFiles.length === 0) setStatus("Idle");
                 }, 4000);
            }

            // Deactivate Nebula mode button if it was active
             if (wasActive && nebulaBtn?.classList.contains("active")) {
                  deactivateAllModes(); // This handles button state and model filtering
             }
        }

        async function startNebulaProcess(userQuery) {
            // Prevent starting if already processing or another Nebula process is active
            isProcessing = true; // Set processing flag
            nebulaProcess.isActive = true; // Set Nebula active flag *IMPORTANT*
            sendBtn.disabled = true; // Disable main send button
            nebulaProcess.userQuery = userQuery;
            nebulaProcess.processId = Date.now(); // Use timestamp as a simple unique ID
            nebulaProcess.messageElement = createNebulaMessageContainer(nebulaProcess.processId); // Create the UI container
            if (!nebulaProcess.messageElement) {
                // Critical error if UI container fails
                cleanupNebulaProcess(true, "Failed to create message container");
                return;
            }
            nebulaProcess.currentStep = 1; // Start at step 1
            disableAllNebulaStepActions(); // Ensure buttons are disabled initially
            requestNebulaStep(1); // Request the first step from backend
        }

        async function requestNebulaStep(stepNumber, isRegeneration = false, regenerationFeedback = null) {
            // Abort if Nebula process is no longer active
            if (!nebulaProcess.isActive) {
                console.warn(`Nebula step ${stepNumber} requested, but process is not active. Aborting.`);
                if (isProcessing) isProcessing = false; // Ensure flag is cleared if request is aborted
                if (sendBtn) sendBtn.disabled = false;
                return;
            }

            // Determine status messages
            const actionDescription = getNebulaStepActionDescription(stepNumber);
            const statusPrefix = isRegeneration ? 'Regenerating' : '';
            const fullStatusText = `Nebula: ${statusPrefix} ${actionDescription}...`;
            const nebulaBoxStatusText = `(${statusPrefix} ${getNebulaStepTitle(stepNumber)}...)`; // Status inside the Nebula message box

            // Update UI status
            if (nebulaProcess.messageElement) {
                const statusSpan = nebulaProcess.messageElement.querySelector('.nebula-status');
                if (statusSpan) {
                    statusSpan.textContent = nebulaBoxStatusText;
                }
            }
            setStatus(fullStatusText); // Update main status bar
            disableAllNebulaStepActions(); // Disable buttons during request
            isProcessing = true; // Set processing flag
            sendBtn.disabled = true; // Disable main send button

            // --- Prepare payload for backend ---
            let endpoint = "/nebula/step";
            let payload = {
                processId: nebulaProcess.processId,
                step: stepNumber,
                model_id: modelSelect.value, // Send currently selected model
                regenerate: isRegeneration,
                context: {} // Context object to hold previous steps' data
            };
            // Add necessary context based on the current step
            payload.context.query = nebulaProcess.userQuery; // Always include original query
            if (stepNumber > 1 && nebulaProcess.planOutput) payload.context.step1 = nebulaProcess.planOutput;
            if (stepNumber > 2 && nebulaProcess.frontendOutput) payload.context.step2 = nebulaProcess.frontendOutput;
             // Include backend output if requesting step 4 OR regenerating step 3
            if (stepNumber > 3 || (isRegeneration && stepNumber === 3)) {
                 if (nebulaProcess.backendOutput) payload.context.step3 = nebulaProcess.backendOutput;
             }
            // Add context specific to regeneration
            if (isRegeneration) {
                 // Include the PREVIOUS output of the step being regenerated, if it exists
                 let previousOutputOfCurrentStep = null;
                 let invalidatedOutput = null; // Output of the step *after* the one being regenerated
                 switch (stepNumber) {
                      case 1: previousOutputOfCurrentStep = nebulaProcess.planOutput; invalidatedOutput = nebulaProcess.frontendOutput; break;
                      case 2: previousOutputOfCurrentStep = nebulaProcess.frontendOutput; invalidatedOutput = nebulaProcess.backendOutput; break;
                      case 3: previousOutputOfCurrentStep = nebulaProcess.backendOutput; invalidatedOutput = nebulaProcess.verificationOutput; break;
                      case 4: previousOutputOfCurrentStep = nebulaProcess.verificationOutput; invalidatedOutput = null; break; // No subsequent step
                 }
                 if (previousOutputOfCurrentStep) {
                      payload.context.current_step_previous_output = previousOutputOfCurrentStep;
                      console.log(`Including PREVIOUS output of Step ${stepNumber} in regeneration context.`);
                 } else {
                      console.log(`No previous output found FOR Step ${stepNumber} to include in regeneration context.`);
                 }
                 // Include the output of the *next* step, as it's now invalid
                 if (invalidatedOutput) {
                      payload.context.current_step_invalidated_output = invalidatedOutput;
                      console.log(`Including INVALIDATED output of Step ${stepNumber + 1} in regeneration context.`);
                 } else {
                       console.log(`No invalidated output found for Step ${stepNumber + 1}.`);
                 }
                // Include user feedback if provided
                if (regenerationFeedback) {
                    payload.context.regeneration_feedback = regenerationFeedback;
                    console.log("Including regeneration feedback:", regenerationFeedback);
                }
            }
            // --- End Payload Preparation ---

            try {
                console.log(`Sending request for Step ${stepNumber} to backend:`, JSON.stringify(payload).substring(0, 500) + '...'); // Log truncated payload
                const response = await fetch(endpoint, { method: "POST", headers: { "Content-Type": "application/json", 'Accept': 'application/json' }, body: JSON.stringify(payload) });
                const responseText = await response.text(); // Get raw response text first
                console.log(`Raw response for Step ${stepNumber} (${response.status}):`, responseText.substring(0, 500) + (responseText.length > 500 ? '...' : '')); // Log truncated raw response

                // Check HTTP status code first
                if (!response.ok) {
                    let errorMsg = `HTTP error ${response.status}`;
                    try {
                         // Try to parse error details from backend JSON response
                        const errData = JSON.parse(responseText);
                        errorMsg = errData.error || errData.message || errorMsg;
                    } catch {} // Ignore parsing errors if response wasn't valid JSON
                    throw new Error(errorMsg); // Throw error to be caught by the catch block
                }

                // Parse JSON only if response.ok
                let data;
                try {
                    data = JSON.parse(responseText);
                } catch (parseError) {
                    console.error("JSON Parse Error:", parseError);
                    throw new Error(`Invalid JSON response received from backend: ${responseText.substring(0, 100)}...`);
                }

                console.log(`Received & Parsed response for Step ${stepNumber}:`, data);
                // Check for application-level errors within the JSON payload
                if (data.error) {
                    throw new Error(data.error);
                }

                // Process successful response
                const output = data.output !== undefined ? data.output : `(No output content received for Step ${stepNumber})`;

                // Store the output in the nebulaProcess object
                switch (stepNumber) {
                    case 1: nebulaProcess.planOutput = output; break;
                    case 2: nebulaProcess.frontendOutput = output; break;
                    case 3: nebulaProcess.backendOutput = output; break;
                    case 4: nebulaProcess.verificationOutput = output; break;
                }

                displayNebulaStepOutput(stepNumber, output); // Update the UI with the received output
                isProcessing = false; // Clear processing flag *after* displaying output

                // Handle next steps based on the completed step
                if (stepNumber >= 1 && stepNumber <= 3) { // If steps 1-3 completed
                    setStatus(`Nebula: Waiting for confirmation on ${getNebulaStepTitle(stepNumber)}...`);
                    sendBtn.disabled = true; // Keep main send button disabled
                    updateNebulaButtonStates(); // Enable Confirm/Regenerate buttons for the current step
                } else if (stepNumber === 4) { // If step 4 completed
                    setStatus(`Nebula: ${actionDescription} complete.`);
                    sendBtn.disabled = false; // Re-enable main send button as process might be done
                    updateNebulaButtonStates(); // Update button states (should all be disabled now)
                    // Check if the backend explicitly signalled completion
                    if (data.status === 'nebula_complete') {
                        handleNebulaCompletion(data); // Final cleanup and potential report link
                    } else {
                        // If step 4 finished but no explicit 'complete' status, assume completion
                         console.log("Step 4 displayed. Assuming completion based on step number.");
                         if (nebulaProcess.messageElement) {
                             const summaryDiv = nebulaProcess.messageElement.querySelector('.nebula-final-summary');
                             // Add a simple finished message if summary is empty
                             if (summaryDiv && !summaryDiv.hasChildNodes()) {
                                 summaryDiv.innerHTML = `<p style="margin-top: 1em; font-style: italic;">Nebula process finished after Step 4.</p>`;
                                 scrollToBottom();
                             }
                         }
                         cleanupNebulaProcess(false); // Perform final cleanup
                    }
                }
            } catch (err) { // Catch network errors or errors thrown from response handling
                console.error(`Error during Nebula Step ${stepNumber} request:`, err);
                cleanupNebulaProcess(true, `Error during ${getNebulaStepActionDescription(stepNumber)}: ${err.message}`); // Cleanup with error state
            }
        }

        function handleNebulaCompletion(data) {
            console.log("Nebula process complete message received from backend.", data);
            if (!nebulaProcess.isActive) {
                console.warn("Received completion message, but Nebula process already inactive.");
                return; // Avoid cleanup if already done
            }
            // Update UI elements for completion
            if (nebulaProcess.messageElement) {
                const summaryDiv = nebulaProcess.messageElement.querySelector('.nebula-final-summary');
                const statusSpan = nebulaProcess.messageElement.querySelector('.nebula-status');
                if (statusSpan) statusSpan.textContent = `(Completed)`; // Update status in message box
                if (summaryDiv) {
                    summaryDiv.innerHTML = `<p style="margin-top: 1em; font-style: italic;">${data.result || 'Code generation process finished.'}</p>`; // Display result message
                    // Add download button if report URL exists
                    if (data.report_url) {
                        nebulaProcess.reportUrl = data.report_url; // Store report URL
                        const buttonsDiv = document.createElement('div');
                        buttonsDiv.classList.add('message-buttons'); // Use existing class for styling
                        buttonsDiv.style.marginTop = '10px';
                        const downloadReportBtn = document.createElement("a");
                        downloadReportBtn.textContent = "Download Report (MD)";
                        downloadReportBtn.classList.add("nebula-download-btn"); // Specific class for styling
                        downloadReportBtn.href = data.report_url;
                        downloadReportBtn.target = "_blank"; // Open in new tab
                        try {
                            // Attempt to set download attribute for nicer filename
                            downloadReportBtn.download = data.report_url.substring(data.report_url.lastIndexOf('/') + 1);
                        } catch {} // Ignore errors setting download attribute
                        buttonsDiv.appendChild(downloadReportBtn);
                        summaryDiv.appendChild(buttonsDiv); // Add button to the summary area
                    }
                    scrollToBottom(); // Scroll to show the summary/button
                }
            }
            setStatus("Nebula: Code generation complete."); // Update main status bar
            cleanupNebulaProcess(false); // Perform final cleanup (without error state)
        }

        function downloadHtml(contentToDownload, currentWidth = 900) {
            if (!contentToDownload) { setStatus("No content to download.", true); setTimeout(() => setStatus(currentStatusText), 2000); return; }
            setStatus("Preparing download...");
            // Basic styles for the downloaded HTML paper
            const styles = ` body { font-family: 'Poppins', sans-serif; line-height: 1.7; color: #333; background-color: #f0f2f5; margin: 0; padding: 20px; } .main-content-wrapper { background-color: #fdfdff; border: 1px solid #eee; padding: 30px; margin: 0 auto; max-width: ${currentWidth}px; } h1, h2, h3, h4, h5, h6 { color: #302b63; margin-top: 1.5em; margin-bottom: 0.5em; } h1 { font-size: 2em; border-bottom: 1px solid #ddd; padding-bottom: 0.3em;} h2 { font-size: 1.6em; } h3 { font-size: 1.3em; } p { margin: 1em 0; } a { color: #7b61ff; text-decoration: none; } a:hover { text-decoration: underline; } pre { background-color: #f0f0f0; padding: 15px; border-radius: 4px; overflow-x: auto; border: 1px solid #ddd; color: #333; white-space: pre-wrap; word-wrap: break-word; font-family: monospace; line-height: 1.6; } code { font-family: monospace; background-color: #eee; padding: 0.2em 0.4em; border-radius: 3px; } pre > code { background-color: transparent; padding: 0; border: none; } .table-wrapper { overflow-x: auto; max-width: 100%; margin: 1em 0; border: 1px solid #ccc; border-radius: 4px; } table { border-collapse: collapse; width: 100%; margin: 0; border: none; } th, td { border: 1px solid #ccc; padding: 8px 12px; text-align: left; word-break: break-word; border-width: 0 0 1px 0; } tr td:first-child, tr th:first-child { border-left: none; } tr td:last-child, tr th:last-child { border-right: none; } tr:last-child td { border-bottom: none; } th { background-color: #f2f2f2; font-weight: 600; } ul, ol { margin-left: 2em; margin-bottom: 1em; } blockquote { border-left: 4px solid #ccc; padding-left: 1em; margin-left: 0; color: #666; } .katex { font-size: 1.1em; } .katex-display { display: block; text-align: center; margin: 1em 0; } .katex-display > .katex { display: inline-block; text-align: initial; } .dl-header, .dl-footer { padding: 10px 30px; max-width: ${currentWidth}px; margin: 20px auto; font-size: 0.9em; color: #555; text-align: center; } .dl-header { border-bottom: 1px dashed #ccc; } .dl-footer { border-top: 1px dashed #ccc; margin-top: 30px; } `;
            const filenameBase = (lastRefinedQuery || "stellar_research").substring(0, 50).replace(/[^a-z0-9_\-\.]/gi, '_').toLowerCase();
            // Construct the full HTML document
            const html = `<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>Stellar Research: ${filenameBase}</title> <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous"> <style>${styles}</style> </head> <body> <div class="dl-header"> <h1>Stellar Research Paper</h1> <p>Generated: ${new Date().toLocaleString()}</p> ${lastRefinedQuery ? `<p>Based on query: "${escapeHtml(lastRefinedQuery)}"</p>` : ''} </div> <div class="main-content-wrapper"> ${contentToDownload} </div> <div class="dl-footer"> <p>Generated by Stellar AI.</p> </div> </body> </html>`;
            try { // Create a Blob and trigger download
                const blob = new Blob([html], { type: "text/html;charset=utf-8" }); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = `${filenameBase}.html`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); setStatus(currentStatusText); // Restore previous status
            } catch (e) { console.error("Download preparation error:", e); setStatus("Download failed.", true); appendStellarMessage("Error preparing download.", Date.now() + '_dl_err'); setTimeout(() => setStatus(currentStatusText), 3000); }
        }

        async function handleFileUpload(event) {
            const files = event.target.files;
            if (!files.length) return;
            const fileNames = Array.from(files).map(f => f.name);
            console.log(`Attempting to upload ${files.length} file(s): ${fileNames.join(', ')}`);
            setStatus(`Uploading ${fileNames.length} file(s)...`); // Brief status
            // analysisProgressArea.innerHTML = ''; // Clear previous errors/progress -> Defer clear until success
            // analysisProgressArea.style.display = 'none'; // Hide initially -> Show on demand

            const formData = new FormData();
            for (const file of files) {
                formData.append('file', file); // Use 'file' as key, backend expects this
            }

            try {
                const response = await fetch('/upload_files', { method: 'POST', body: formData });

                if (!response.ok) {
                    // Try to get error from JSON, fallback to status text
                    const errData = await response.json().catch(() => ({ error: `HTTP error ${response.status}` }));
                    throw new Error(errData.error || `HTTP error ${response.status}`);
                }

                const data = await response.json();
                console.log('Upload Response:', data);

                if (data.uploaded_files && data.uploaded_files.length > 0) {
                    // Add successfully uploaded files to the pending list
                    pendingAnalysisFiles.push(...data.uploaded_files);
                    pendingAnalysisFiles = [...new Set(pendingAnalysisFiles)]; // Remove duplicates
                    console.log("Pending analysis files:", pendingAnalysisFiles);
                    updatePendingFilesIndicator(); // Update UI indicator
                    setStatus(`Uploaded ${data.uploaded_files.length} file(s). Ready for analysis.`);
                } else {
                    // Handle cases where no files were uploaded (e.g., all disallowed)
                    setStatus(data.status || "Upload processed, no new files saved.");
                }

                // Display errors for failed/disallowed files
                if (data.files_failed?.length || data.files_disallowed?.length) {
                     analysisProgressArea.style.display = 'flex'; // Ensure area is visible
                    data.files_failed?.forEach(fname => displayUploadError(fname, "Save failed on server."));
                    data.files_disallowed?.forEach(fname => displayUploadError(fname, "File type not allowed."));
                }

                 // --- Status Update Logic ---
                 const hasErrors = data.files_failed?.length || data.files_disallowed?.length;
                 const delay = hasErrors ? 4000 : 2500; // Longer delay if errors were shown

                 setTimeout(() => {
                     // Check if app should be idle *after* the delay
                     const shouldBeIdle = !isProcessing && !nebulaProcess.isActive && pendingAnalysisFiles.length === 0 && analysisProgressArea.childElementCount === 0;
                     if (shouldBeIdle) {
                         setStatus("Idle");
                     } else {
                         // Restore previous status if still busy (e.g., mid-Nebula)
                         setStatus(currentStatusText, false);
                     }
                 }, delay);
                 // --- End Status Update Logic ---


            } catch (error) {
                console.error(`Error during file upload request:`, error);
                const errorMsg = `Upload request failed: ${error.message}`;
                setStatus(errorMsg, true);
                analysisProgressArea.style.display = 'flex'; // Show progress area for errors
                // Display error for all attempted files if the request itself failed
                fileNames.forEach(fname => displayUploadError(fname, "Network or server error during upload."));

                 setTimeout(() => {
                     // Restore status after error display, only go Idle if nothing else is running
                     const shouldBeIdle = !isProcessing && !nebulaProcess.isActive && analysisProgressArea.childElementCount === 0;
                     if (shouldBeIdle) {
                        setStatus("Idle");
                     } else {
                         setStatus(currentStatusText, false); // Revert to previous non-error status if still busy
                     }
                 }, 4000); // Keep error status longer
            } finally {
                // Clear the file input so the same file can be selected again
                event.target.value = null;
                updateStatusBarPosition(); // Adjust status bar in case progress area appeared/disappeared
            }
        }


         function displayUploadError(filename, errorMsg) {
             if (!analysisProgressArea) return;
             analysisProgressArea.style.display = 'flex'; // Ensure area is visible for errors

             // Sanitize filename for use as ID
             let sanitizedId = filename.replace(/[^a-zA-Z0-9-_]/g, '');
             let progressDiv = document.getElementById('progress-' + sanitizedId);

             // Create new error item if one doesn't exist for this file
             if (!progressDiv) {
                  progressDiv = document.createElement('div');
                  progressDiv.id = 'progress-' + sanitizedId;
                  progressDiv.className = 'file-progress-item status-error'; // Add error class
                  progressDiv.innerHTML = `
                      <div class="summary">
                          ğŸ“„ <strong>${filename}</strong>: <span class="status">Upload Failed</span>
                      </div>
                      <div class="details" style="display: block; padding-left: 20px; border-left: 1px solid var(--stellar-msg-border); margin-left: 10px;">
                          <strong style="color: var(--nebula-regenerate-start);">${new Date().toLocaleTimeString()}: ${errorMsg}</strong><br>
                      </div>`;
                  analysisProgressArea.appendChild(progressDiv);
              } else {
                   // Update existing item if it was already shown (e.g., during analysis)
                   const statusSpan = progressDiv.querySelector('.summary .status');
                   const detailsDiv = progressDiv.querySelector('.details');
                   if (statusSpan) statusSpan.textContent = 'Upload Failed';
                   if (detailsDiv) {
                        detailsDiv.innerHTML += `<strong style="color: var(--nebula-regenerate-start);">${new Date().toLocaleTimeString()}: ${errorMsg}</strong><br>`;
                        detailsDiv.style.display = 'block'; // Ensure details are visible
                   }
                   progressDiv.classList.add('status-error'); // Ensure error class is present
              }
               updateStatusBarPosition(); // Adjust status bar position

               // Auto-hide the error message after a delay
               setTimeout(() => {
                   if(progressDiv && progressDiv.parentNode === analysisProgressArea){
                        progressDiv.style.transition = 'opacity 0.5s ease';
                        progressDiv.style.opacity = '0';
                        setTimeout(() => {
                           if(progressDiv.parentNode === analysisProgressArea) { // Check again in case it was removed by other means
                               analysisProgressArea.removeChild(progressDiv);
                               // Hide the progress area if it's now empty
                               if (analysisProgressArea.childElementCount === 0) {
                                    analysisProgressArea.style.display = 'none';
                               }
                           }
                           updateStatusBarPosition(); // Adjust status bar again
                        }, 500); // Wait for fade out transition
                   }
               }, 7000); // 7 seconds display time for errors
         }


         function initializeSSE() {
             // Prevent multiple connections
             if (sseEventSource && sseEventSource.readyState !== EventSource.CLOSED) {
                 console.log("SSE connection already open.");
                 return;
             }
             console.log("Initializing SSE connection for analysis progress...");
             sseEventSource = new EventSource('/analysis_progress'); // Backend endpoint

             sseEventSource.onopen = function() {
                 console.log("SSE connection opened.");
                  // Remove any lingering connection error messages
                 const errorMsgDiv = document.getElementById('sse-conn-error-msg');
                 if (errorMsgDiv) errorMsgDiv.remove();
             };

            sseEventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    console.log("SSE Message (Analysis Progress):", data);

                    // Basic validation
                    if (!data.filename && !['sse_connected', 'sse_error'].includes(data.type)) {
                       console.warn("SSE progress message missing filename:", data);
                       return; // Ignore messages without filenames unless they are meta-messages
                    }

                    let fileProgressId = data.filename ? 'progress-' + data.filename.replace(/[^a-zA-Z0-9-_]/g, '') : null;
                    let progressDiv = fileProgressId ? document.getElementById(fileProgressId) : null;

                    // Create progress item if it doesn't exist (and it's not just an end signal)
                    if (!progressDiv && fileProgressId && data.type !== 'analysis_thread_end') {
                        progressDiv = document.createElement('div');
                        progressDiv.id = fileProgressId;
                        progressDiv.className = 'file-progress-item'; // Base class
                        progressDiv.innerHTML = `
                            <div class="summary" style="cursor: pointer;">
                                ğŸ“„ <strong>${data.filename}</strong>: <span class="status">Receiving updates...</span>
                            </div>
                            <div class="details" style="display: none; padding-left: 20px; border-left: 1px solid var(--stellar-msg-border); margin-left: 10px;">
                                <small>Analysis Details:</small><br>
                            </div>`;
                        // Make summary clickable to toggle details
                        progressDiv.querySelector('.summary').onclick = () => {
                            const detailsDiv = progressDiv.querySelector('.details');
                            if (detailsDiv) {
                                detailsDiv.style.display = detailsDiv.style.display === 'none' ? 'block' : 'none';
                                if (detailsDiv.style.display === 'block') {
                                     detailsDiv.scrollTop = detailsDiv.scrollHeight; // Scroll to bottom when opened
                                }
                            }
                        };
                        if(analysisProgressArea) {
                             analysisProgressArea.appendChild(progressDiv); // Add to the UI
                             analysisProgressArea.style.display = 'flex'; // Ensure area is visible
                         }
                         updateStatusBarPosition(); // Adjust status bar
                    }

                    // Update the content of the progress item based on message type
                     if (progressDiv) {
                        const statusSpan = progressDiv.querySelector('.summary .status');
                        const detailsDiv = progressDiv.querySelector('.details');
                        let isCompleteOrError = false; // Flag to trigger auto-hide later

                        if (!statusSpan || !detailsDiv) {
                             console.error("Progress item structure invalid:", progressDiv.id);
                             return;
                        }

                        // Handle different message types
                        switch (data.type) {
                            case 'file_start':
                                statusSpan.textContent = 'Starting...';
                                detailsDiv.innerHTML += `<small>${new Date().toLocaleTimeString()}: Analysis started.</small><br>`;
                                break;
                            case 'progress':
                                const progressMsg = data.message || (data.chunk_num ? `Processing chunk ${data.chunk_num}/${data.total_chunks}...` : 'Processing...');
                                statusSpan.textContent = progressMsg;
                                // Add more detailed message to the details section
                                if(data.chunk_num) { detailsDiv.innerHTML += `<small>${new Date().toLocaleTimeString()}: Chunk ${data.chunk_num}/${data.total_chunks} - ${progressMsg}</small><br>`; }
                                else { detailsDiv.innerHTML += `<small>${new Date().toLocaleTimeString()}: ${progressMsg}</small><br>`; }
                                break;
                            case 'file_chunk_info': // e.g., "Split into 5 chunks"
                                statusSpan.textContent = `Split into ${data.total_chunks} chunks.`;
                                detailsDiv.innerHTML += `<small>${new Date().toLocaleTimeString()}: Splitting complete (${data.total_chunks} chunks).</small><br>`;
                                break;
                            case 'chunk_result': // e.g., "Analyzed chunk 3/5"
                                statusSpan.textContent = `Analyzed chunk ${data.chunk_num}/${data.total_chunks}...`;
                                detailsDiv.innerHTML += `<small>${new Date().toLocaleTimeString()}: Chunk ${data.chunk_num}/${data.total_chunks} analysis complete.</small><br>`;
                                break;
                            case 'file_complete': // Final success/completion state
                                statusSpan.textContent = `Complete (${data.status})`;
                                detailsDiv.innerHTML += `<strong>${new Date().toLocaleTimeString()}: Finished - ${data.status}</strong><br>`;
                                // Add success/finished class for styling
                                progressDiv.classList.add(data.status.toLowerCase().includes('success') ? 'status-success' : 'status-finished');
                                isCompleteOrError = true;
                                break;
                            case 'chunk_error': // Error during a specific chunk
                            case 'file_error': // Error during overall file processing
                                statusSpan.textContent = `Error`;
                                detailsDiv.innerHTML += `<strong style="color: var(--nebula-regenerate-start);">${new Date().toLocaleTimeString()}: Error (Chunk ${data.chunk_num || 'N/A'}) - ${data.error}</strong><br>`;
                                progressDiv.classList.add('status-error'); // Add error class
                                isCompleteOrError = true;
                                break;
                            case 'analysis_thread_end': // Backend thread finished for this file
                                 // Check if it didn't already report complete/error
                                 if (!progressDiv.classList.contains('status-success') && !progressDiv.classList.contains('status-finished') && !progressDiv.classList.contains('status-error')) {
                                     statusSpan.textContent = `Processing Ended`;
                                     detailsDiv.innerHTML += `<small>${new Date().toLocaleTimeString()}: Background processing ended.</small><br>`;
                                     progressDiv.classList.add('status-ended'); // Add class to indicate it ended without specific status
                                 }
                                 isCompleteOrError = true;
                                 break;
                            case 'sse_connected': // Confirmation from backend
                                console.log("SSE stream connected confirmation received.");
                                break;
                            case 'sse_error': // Error message specifically about the SSE stream itself
                                console.error("SSE stream error reported by server:", data.error);
                                // Potentially display a global error, but rely on onerror for connection loss
                                break;
                            default:
                                console.warn("Unknown SSE message type:", data.type, data);
                        }

                        // Auto-scroll details if they are visible
                        if(detailsDiv.style.display !== 'none') {
                            detailsDiv.scrollTop = detailsDiv.scrollHeight;
                        }

                        // Auto-hide completed/error items after a delay
                        if(isCompleteOrError && analysisProgressArea){
                             const hideDelay = progressDiv.classList.contains('status-error') ? 7000 : 5000; // Longer delay for errors
                            setTimeout(() => {
                                if(progressDiv && progressDiv.parentNode === analysisProgressArea){ // Check if still exists
                                     progressDiv.style.transition = 'opacity 0.5s ease';
                                     progressDiv.style.opacity = '0';
                                     // Remove from DOM after fade out
                                     setTimeout(() => {
                                         if(progressDiv.parentNode === analysisProgressArea) { // Check again
                                             analysisProgressArea.removeChild(progressDiv);
                                             // Hide the whole area if it becomes empty
                                             if (analysisProgressArea.childElementCount === 0) {
                                                 analysisProgressArea.style.display = 'none';
                                             }
                                         }
                                         updateStatusBarPosition(); // Adjust status bar
                                      }, 500); // Match transition duration
                                }
                            }, hideDelay);
                        }
                     }
                } catch (e) {
                    console.error("Error parsing SSE message:", event.data, e);
                }
                 updateStatusBarPosition(); // Update status bar after processing message
            };

            sseEventSource.onerror = function(err) {
                console.error("EventSource failed:", err);
                // Display a connection error message in the progress area
                if (analysisProgressArea && !document.getElementById('sse-conn-error-msg')) {
                     const errorMsgDiv = document.createElement('div');
                     errorMsgDiv.id = 'sse-conn-error-msg';
                     errorMsgDiv.innerHTML = '<p style="color: red; font-size: 0.8em; text-align: center;">Progress connection lost. Will attempt reconnect.</p>';
                     errorMsgDiv.style.padding = '5px';
                     errorMsgDiv.style.border = '1px dashed red';
                     errorMsgDiv.style.borderRadius = '4px';
                     analysisProgressArea.appendChild(errorMsgDiv);
                     analysisProgressArea.style.display = 'flex';
                     updateStatusBarPosition();
                }
                setStatus("Progress connection error", true); // Show error in main status bar
                // Close the failed connection
                if(sseEventSource) sseEventSource.close();
                sseEventSource = null;

                // Attempt to reconnect after a delay
                setTimeout(() => {
                     // Remove the connection error message before retrying
                     const errorMsgDiv = document.getElementById('sse-conn-error-msg');
                     if (errorMsgDiv) errorMsgDiv.remove();
                     console.log("Attempting to re-initialize SSE connection...");
                     initializeSSE(); // Try to start a new connection
                 }, 10000); // Reconnect after 10 seconds
            };
        }

        function updatePendingFilesIndicator() {
            const indicatorArea = document.getElementById('pendingFilesIndicator');
            if (indicatorArea) {
                if (pendingAnalysisFiles.length > 0) {
                     // Display the count of pending files
                     indicatorArea.textContent = `Files ready for analysis: ${pendingAnalysisFiles.length}`;
                     indicatorArea.style.display = 'block'; // Show the indicator
                } else {
                    // Hide the indicator if no files are pending
                    indicatorArea.textContent = '';
                     indicatorArea.style.display = 'none';
                }
            }
             updateStatusBarPosition(); // Update status bar position as indicator height might change
        }


        async function handleSend() {
            // --- **REMOVED** Nebula Mode Checks ---
            /* // <<< COMMENTED OUT BLOCK START
            if (isNebulaMode) {
                 // Block if a Nebula process is *truly* active and requires user action or is processing
                 const nebulaIsBlocking = nebulaProcess.isActive &&
                                          (isProcessing || (nebulaProcess.currentStep >= 1 && nebulaProcess.currentStep <= 3 && !isProcessing));
                 if (nebulaIsBlocking) {
                     let reason = isProcessing
                         ? `Please wait for Nebula ${getNebulaStepTitle(nebulaProcess.currentStep)} to complete.`
                         : `Please Confirm or Regenerate Nebula Step ${nebulaProcess.currentStep}.`;
                     console.warn("Cannot start new Nebula process:", reason);
                     setStatus(reason, true);
                     setTimeout(() => setStatus(currentStatusText, false), 3000);
                     return; // Block the send action
                 }
                 // If Nebula mode is ON, but nebulaProcess.isActive is false or currentStep is 0 or >=4, allow starting a new process.
            }
            */ // <<< COMMENTED OUT BLOCK END
            // --- End Removed Nebula Checks ---

            // --- General Processing Check (for non-Nebula) ---
            // Keep this check to prevent spamming non-Nebula requests while one is processing
            if (!isNebulaMode && isProcessing) {
                console.warn("General processing is active, blocking new request.");
                setStatus("Please wait for the current request to complete.", true);
                setTimeout(() => setStatus(currentStatusText, false), 2000);
                return; // Block non-Nebula requests if general processing is active
            }
            // --- End General Processing Check ---


            const query = chatInput.value.trim();
            if (!query && pendingAnalysisFiles.length === 0) return; // Nothing to send

            const selectedModel = modelSelect.value;
            // Mode determination remains the same
            const mode = isNebulaMode ? 'nebula' : (isResearchMode ? (useSpectrumSearch ? 'search_tavily' : 'search_no_tavily') : 'refine');

            // --- Set Processing State ---
            isProcessing = true; // Set general processing flag (will be cleared by specific handlers)
            // Disable send button *only if* starting Nebula or if files are present for other modes
             // No change needed here, disabling for Nebula start is still reasonable
            let shouldDisableSendButton = (mode === 'nebula') || (pendingAnalysisFiles.length > 0);
            if (shouldDisableSendButton) { sendBtn.disabled = true; }
            setStatus("Processing...");
            // --- End Set Processing State ---

            const userMsgId = Date.now() + '_user';
            if (query) { appendUserMessage(query, userMsgId); }
            const originalQuery = query;
            chatInput.value = "";
            adjustTextareaHeight();

            const filesToAnalyze = [...pendingAnalysisFiles]; // Copy files for this request
            let placeholderId = `placeholder-${Date.now()}`;
            let placeholderText = query ? "Processing query..." : "Processing files...";
            let hasFiles = filesToAnalyze.length > 0;

            if (hasFiles) {
                placeholderText = query ? `Analyzing ${filesToAnalyze.length} file(s) and processing query...` : `Analyzing ${filesToAnalyze.length} file(s)...`;
                pendingAnalysisFiles = []; // Clear the global list *now*
                updatePendingFilesIndicator();
                if (!sseEventSource || sseEventSource.readyState === EventSource.CLOSED) { initializeSSE(); }
            }
            

            // --- Route to Correct Handler ---
             if (mode === 'nebula') {
                 if (!query) {
                     setStatus("Please describe the application you want Nebula to generate.", true);
                     isProcessing = false; // Reset processing flag
                     sendBtn.disabled = false; // Re-enable send button
                      updateStellarMessagePlaceholder(placeholderId, "Nebula requires a description.", true);
                      setTimeout(() => {
                          const placeholderDiv = messagesDiv.querySelector(`.message[data-id="${placeholderId}"]`);
                          if (placeholderDiv) placeholderDiv.remove();
                          setStatus(currentStatusText, false);
                      }, 3000);
                     return;
                 }
                 // Now it just directly calls startNebulaProcess without checking nebulaProcess.isActive
                 startNebulaProcess(originalQuery);
                 // Note: startNebulaProcess handles its own status updates and processing flags internally
                 // The return statement below was causing the error because the 'else' block was missing a closing brace
                 return; // Stop further execution in handleSend for Nebula

             } else { // Handle Refine or Spectrum modes
                try {
                    appendStellarMessagePlaceholder(placeholderId, placeholderText, hasFiles);
                    const registerPayload = { query: originalQuery, model_id: selectedModel, mode: mode, pending_files: filesToAnalyze };
                    console.log("Registering Query:", registerPayload);
                    const response = await fetch('/register_query', { method: 'POST', headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' }, body: JSON.stringify(registerPayload) });
                    if (!response.ok) { const errData = await response.json().catch(() => ({})); throw new Error(errData.error || `Failed to register query (HTTP ${response.status})`); }
                    const data = await response.json();
                    if (!data.query_id) { throw new Error("Backend did not return a query_id."); }

                    const query_id = data.query_id;
                    console.log(`Query registered ID: ${query_id}. Mode: ${mode}. Files: ${filesToAnalyze.length}`);
                    lastRefinedQuery = originalQuery;

                    const streamUrl = mode === 'refine' ? '/refine_stream' : '/search_stream';
                    const params = new URLSearchParams({ query_id: query_id });
                    if (mode !== 'refine') { params.append('useTavily', (mode === 'search_tavily').toString()); }

                    // startStreaming will handle setting isProcessing=false in its cleanup
                    startStreaming(streamUrl, params, placeholderId, userMsgId, hasFiles);

                } catch (err) {
                    console.error("Error during query registration or stream initiation:", err);
                    const errorMsg = `Error sending request: ${err.message}`;
                    updateStellarMessagePlaceholder(placeholderId, errorMsg, true);
                    setStatus(`Error: ${err.message}`, true);
                    isProcessing = false; // **CRITICAL:** Reset isProcessing on registration error
                    sendBtn.disabled = false; // Re-enable button
                    setTimeout(() => setStatus(currentStatusText, false), 4000);
                }
            } // <<< --- ADDED THIS MISSING CLOSING BRACE
        }

        function appendStellarMessagePlaceholder(id, initialText, hasFiles) {
            const msg = document.createElement("div");
            msg.classList.add("message", "stellar-msg", "placeholder-message");
            msg.dataset.id = id; // Use the placeholder ID

            const contentDiv = document.createElement("div");
            contentDiv.classList.add("message-content");

            const statusSpan = document.createElement("span");
            statusSpan.className = "placeholder-status";
            // Make status clickable only if files were involved (to show analysis details later)
            if (hasFiles) {
                statusSpan.classList.add("clickable", "analysis-placeholder");
            }
            statusSpan.textContent = initialText;

            contentDiv.appendChild(statusSpan);

            // Add a hidden div to hold analysis details if files were processed
            if (hasFiles) {
                const detailsDiv = document.createElement("div");
                detailsDiv.className = "analysis-content";
                detailsDiv.style.display = "none"; // Initially hidden
                detailsDiv.innerHTML = "<small><i>Waiting for analysis updates...</i></small>";
                contentDiv.appendChild(detailsDiv);
            }

            msg.appendChild(contentDiv);
            if (messagesDiv) messagesDiv.appendChild(msg); // Add to chat
            scrollToBottom();
        }


        function updateStellarMessagePlaceholder(id, newText, isError = false, analysisDetails = null) {
            const msgDiv = messagesDiv.querySelector(`.message[data-id="${id}"]`);
            if (!msgDiv) {
                console.warn("Placeholder message div not found for update:", id);
                // If placeholder is gone but there's an error, append a new error message
                if (isError) appendStellarMessage(`Error: ${newText}`, id + "_err");
                return;
            }
            const statusSpan = msgDiv.querySelector('.placeholder-status');
            const detailsDiv = msgDiv.querySelector('.analysis-content');

            // Update the main status text
            if (statusSpan) {
                statusSpan.textContent = newText;
                if (isError) {
                    statusSpan.style.color = 'var(--nebula-regenerate-start, #ff6b6b)'; // Use error color
                    statusSpan.classList.remove("clickable", "analysis-placeholder"); // Not clickable on error
                     statusSpan.onclick = null; // Remove click listener if it exists
                } else {
                    statusSpan.style.color = ''; // Reset color
                     // Ensure it's clickable if analysis details are present/expected
                     if (detailsDiv && !statusSpan.classList.contains("clickable")) {
                          statusSpan.classList.add("clickable", "analysis-placeholder");
                          // Add click listener if it wasn't there (e.g., if files finished *after* placeholder was added)
                          if (!statusSpan.onclick) {
                               statusSpan.onclick = () => toggleAnalysisDetails(msgDiv);
                          }
                     }
                }
            }

            // Update or add the analysis details section if provided
            if (detailsDiv && analysisDetails) {
                 let detailsHtml = '';
                 if (typeof analysisDetails === 'string') {
                      // If details are just a string, wrap in pre for basic formatting
                     detailsHtml = `<pre>${escapeHtml(analysisDetails)}</pre>`;
                 } else if (typeof analysisDetails === 'object' && analysisDetails !== null) {
                      // If details are an object (likely filename: result mapping), format as a list
                      detailsHtml += '<small>Analysis Results:</small><ul>';
                      for(const [filename, result] of Object.entries(analysisDetails)) {
                           // Show a snippet of the result
                           const shortResult = result ? result.substring(0, 300) + (result.length > 300 ? '...' : '') : '(No result)';
                           detailsHtml += `<li><strong>${escapeHtml(filename)}:</strong><pre>${escapeHtml(shortResult)}</pre></li>`;
                      }
                      detailsHtml += '</ul>';
                 } else {
                      detailsHtml = '<small><i>No analysis details provided.</i></small>';
                 }
                detailsDiv.innerHTML = detailsHtml; // Update the details div content
            }
        }


        function finalizeStellarMessage(placeholderId, finalContent, messageDbId, analysisContextUsed = null) {
             const placeholderDiv = messagesDiv.querySelector(`.message[data-id="${placeholderId}"]`);

             // If placeholder somehow disappeared, append a new message instead of replacing
             if (!placeholderDiv) {
                 console.warn(`Placeholder ${placeholderId} not found for finalization. Appending new message.`);
                 if (analysisContextUsed) {
                     // Use specific function if analysis context needs to be added
                     appendStellarMessageWithAnalysis(finalContent, messageDbId, analysisContextUsed);
                 } else {
                     appendStellarMessage(finalContent, messageDbId);
                 }
                 return;
             }

             // Update the placeholder's ID to the final database ID
             placeholderDiv.dataset.id = messageDbId;
             // Remove the placeholder class
             placeholderDiv.classList.remove("placeholder-message");

             // Get the content div, or create if missing (defensive coding)
             let contentDiv = placeholderDiv.querySelector('.message-content');
             if (!contentDiv) {
                 console.error("Content div missing in placeholder during finalization!");
                 placeholderDiv.innerHTML = ''; // Clear potentially broken content
                 const newContentDiv = document.createElement('div');
                 newContentDiv.classList.add('message-content');
                 placeholderDiv.appendChild(newContentDiv);
                 contentDiv = newContentDiv;
             } else {
                  // Clear any previous placeholder text/structure
                  contentDiv.innerHTML = '';
             }

             try {
                 // Parse the final Markdown content
                 let htmlContent = marked.parse(finalContent || "");
                 htmlContent = wrapTables(htmlContent); // Wrap tables
                 contentDiv.innerHTML = htmlContent; // Set the final HTML
                 processCodeBlocks(contentDiv); // Apply syntax highlighting, add copy/preview buttons

                 // Add the analysis indicator if context was used
                 if (analysisContextUsed) {
                     addAnalysisIndicator(placeholderDiv, analysisContextUsed);
                 }

                 // Add research buttons if this was a research output
                 if (placeholderDiv.classList.contains('research-output')) {
                      createAndAppendResearchButtons(placeholderDiv, messageDbId, contentDiv.innerHTML);
                 }

                 // Render math equations after a short delay
                 setTimeout(() => {
                     renderMath(contentDiv);
                     scrollToBottom(); // Ensure final message is visible
                 }, 200);

             } catch (e) {
                 console.error("MD Parse Error (Finalize):", e);
                 contentDiv.textContent = "Error displaying content."; // Fallback text
                 // Still try to add analysis indicator if applicable
                 if (analysisContextUsed) {
                     addAnalysisIndicator(placeholderDiv, analysisContextUsed);
                 }
                 scrollToBottom();
             }
        }


        function addAnalysisIndicator(messageDiv, analysisContext) {
            if (!messageDiv || !analysisContext) return;
            const contentDiv = messageDiv.querySelector('.message-content');
            if (!contentDiv) return;

            // Remove any existing indicators/details divs from previous updates/placeholders
            contentDiv.querySelectorAll('.analysis-indicator, .analysis-content').forEach(el => el.remove());

            // Create the clickable indicator text (e.g., "Analyzed files")
            const indicatorSpan = document.createElement("span");
            indicatorSpan.className = "analysis-indicator clickable"; // Classes for styling and click handling
            indicatorSpan.textContent = " Analyzed files"; // Leading space for separation
            // Styling (can also be done purely in CSS)
            indicatorSpan.style.fontSize = '0.85em';
            indicatorSpan.style.color = 'var(--secondary-text-color)';
            indicatorSpan.style.cursor = 'pointer';
            indicatorSpan.style.marginLeft = '10px'; // Space from main content

            // Create the hidden div to hold the formatted analysis context
            const detailsDiv = document.createElement("div");
            detailsDiv.className = "analysis-content"; // Class for styling
            detailsDiv.style.display = "none"; // Initially hidden
            detailsDiv.style.marginTop = "10px"; // Spacing
            detailsDiv.style.paddingTop = "10px";
            detailsDiv.style.borderTop = "1px dashed var(--stellar-msg-border)"; // Separator line
             // Populate with formatted context
            detailsDiv.innerHTML = `<small><i>Context provided to model:</i></small><div class="formatted-analysis-context">${formatAnalysisContextForDisplay(analysisContext)}</div>`;

            // Append the indicator and details div to the message content
            contentDiv.appendChild(indicatorSpan);
            contentDiv.appendChild(detailsDiv);

             // Add click listener to the indicator (delegated in main event listener)
             // The main listener looks for '.analysis-indicator.clickable'
        }


        function formatAnalysisContextForDisplay(rawContext) {
    if (!rawContext || typeof rawContext !== 'string') return "<p>No analysis context was provided.</p>";

    try {
        let processedHtml = '';
        try {
            processedHtml = marked.parse(rawContext || "");
        } catch (parseError) {
            console.error("Initial markdown parse error:", parseError);
            processedHtml = `<pre>Error parsing context: ${escapeHtml(parseError.message)}\n\n${escapeHtml(rawContext)}</pre>`;
            // If initial parse fails, wrap in pre and return early, as DOM manipulation might fail too.
            return processedHtml;
        }

        const parser = new DOMParser();
        const doc = parser.parseFromString(`<div id="context-wrapper">${processedHtml}</div>`, 'text/html');
        const wrapper = doc.getElementById('context-wrapper');
        if (!wrapper) return `<pre>${escapeHtml(rawContext)}</pre>`; // Fallback if parsing fails badly

        wrapper.querySelectorAll('details').forEach(details => {
            let summary = details.querySelector('summary');
            if (!summary) {
                summary = doc.createElement('summary');
                summary.textContent = 'Details';
                details.insertBefore(summary, details.firstChild);
            }
            summary.style.cursor = 'pointer';
            summary.style.fontWeight = 'bold';
            summary.style.color = 'var(--primary-text-color)';
            summary.style.padding = '8px';
            summary.style.display = 'block';
            summary.style.backgroundColor = 'rgba(255, 255, 255, 0.03)';
            summary.style.borderRadius = '4px 4px 0 0';

            let contentWrapper = summary.nextElementSibling;
            if (contentWrapper && (contentWrapper.tagName === 'DIV' || contentWrapper.tagName === 'PRE')) {
                contentWrapper.style.padding = '10px';
                contentWrapper.style.borderTop = '1px dashed rgba(255, 255, 255, 0.1)';
                contentWrapper.style.marginTop = '0';
                contentWrapper.style.backgroundColor = 'rgba(0,0,0,0.1)';
            } else {
                const newWrapper = doc.createElement('div');
                newWrapper.style.padding = '10px';
                newWrapper.style.borderTop = '1px dashed rgba(255, 255, 255, 0.1)';
                newWrapper.style.marginTop = '0';
                newWrapper.style.backgroundColor = 'rgba(0,0,0,0.1)';
                while (summary.nextSibling) {
                    newWrapper.appendChild(summary.nextSibling);
                }
                details.appendChild(newWrapper);
            }

            details.style.border = '1px solid rgba(255, 255, 255, 0.1)';
            details.style.borderRadius = '4px';
            details.style.marginBottom = '10px';
            details.style.backgroundColor = 'rgba(0, 0, 0, 0.05)';
        });

         wrapper.querySelectorAll(':scope > pre').forEach(pre => {
             if (pre.closest('details')) return;

             pre.style.marginTop = '10px';
             pre.style.marginBottom = '10px';
             pre.style.padding = '12px';
             pre.style.fontSize = '0.9em';
             pre.style.backgroundColor = 'rgba(0,0,0,0.25)';
             pre.style.border = '1px solid rgba(255,255,255,0.15)';
             pre.style.borderRadius = '4px';
             pre.style.whiteSpace = 'pre-wrap';
             pre.style.wordWrap = 'break-word';
         });

        // Attempt to remove leftover markdown emphasis/headers after marked.js parsing
        let finalHtml = wrapper.innerHTML;
        finalHtml = finalHtml.replace(/##\s*(.*?)\s*(<br\s*\/?>)?/g, '<h3>$1</h3>'); // Basic ## handling -> h3
        finalHtml = finalHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); // **bold** -> <strong>
        finalHtml = finalHtml.replace(/__(.*?)__/g, '<strong>$1</strong>'); // __bold__ -> <strong>
        finalHtml = finalHtml.replace(/\*(.*?)\*/g, '<em>$1</em>'); // *italic* -> <em>
        finalHtml = finalHtml.replace(/_(.*?)_/g, '<em>$1</em>'); // _italic_ -> <em>
        finalHtml = finalHtml.replace(/`([^`]+)`/g, '<code>$1</code>'); // `code` -> <code>

        return finalHtml;

    } catch (e) {
        console.error("Error formatting analysis context:", e);
        return `<pre>${escapeHtml(rawContext)}</pre>`;
    }
}



        function appendStellarMessageWithAnalysis(markdownText, id, analysisContext) {
             const msg = document.createElement("div");
             msg.classList.add("message", "stellar-msg");
             msg.dataset.id = id;
             const contentDiv = document.createElement("div");
             contentDiv.classList.add("message-content");
             try {
                 let htmlContent = marked.parse(markdownText || "");
                 htmlContent = wrapTables(htmlContent);
                 contentDiv.innerHTML = htmlContent;
                 processCodeBlocks(contentDiv);

                 // Add the indicator and details section
                 addAnalysisIndicator(msg, analysisContext);

                 setTimeout(() => {
                     renderMath(contentDiv); // Render math in main content
                     // Also render math within the analysis details if needed
                     const analysisDetailsEl = msg.querySelector('.analysis-content .formatted-analysis-context');
                     if (analysisDetailsEl) renderMath(analysisDetailsEl);
                     scrollToBottom();
                 }, 200);
             } catch (e) {
                 console.error("MD Parse Error (Stellar w/ Analysis):", e);
                 contentDiv.textContent = "Error displaying content.";
                 // Still try to add indicator even if main content fails
                 addAnalysisIndicator(msg, analysisContext);
                 scrollToBottom();
             }
             msg.appendChild(contentDiv);
             if (messagesDiv) messagesDiv.appendChild(msg);
        }


        function startStreaming(streamUrl, params, placeholderId, userMessageId, hasFiles) {
            let source = null;
            let fullResponseContent = "";
            let analysisContextReceived = null; // To store context string from backend
            let analysisResultsReceived = null; // To store structured results if sent
            let streamEndedCleanly = false; // Flag to prevent error handling if stream ends normally

            // Centralized cleanup function
            const cleanup = (showErrorStatus = false, errorMsg = null) => {
                if (source) { // Close EventSource if open
                     console.log("Closing SSE stream connection.");
                     source.close();
                     source = null;
                 }
                isProcessing = false; // Clear processing flag

                // Re-enable send button only if Nebula is not active
                if (!nebulaProcess.isActive) {
                     sendBtn.disabled = false;
                }

                // Determine final status bar message
                const finalStatus = showErrorStatus ? (errorMsg || "Stream Error") : "Idle";
                // Check if app should be idle after this stream finishes
                const shouldBeIdle = !isProcessing && !nebulaProcess.isActive && pendingAnalysisFiles.length === 0 && analysisProgressArea?.childElementCount === 0;
                setStatus(showErrorStatus ? finalStatus : (shouldBeIdle ? "Idle" : currentStatusText), showErrorStatus);

                // If there was an error, update the placeholder and set a timeout to potentially clear the error status
                if (showErrorStatus) {
                    updateStellarMessagePlaceholder(placeholderId, `Error: ${errorMsg || 'Failed'}`, true);
                    setTimeout(() => {
                        // Re-check idle status after timeout
                        const shouldBeIdleAfterError = !isProcessing && !nebulaProcess.isActive && pendingAnalysisFiles.length === 0 && analysisProgressArea?.childElementCount === 0;
                        setStatus(shouldBeIdleAfterError ? "Idle" : currentStatusText, false); // Clear error state unless still busy
                    }, 4000);
                }
            };

            try {
                console.log(`Starting stream: ${streamUrl}?${params.toString()}`);
                source = new EventSource(`${streamUrl}?${params.toString()}`);

                source.onmessage = (event) => {
                    if (!event.data || event.data.trim() === "") return; // Ignore empty messages
                    try {
                        const data = JSON.parse(event.data);
                        console.log("SSE Stream Data:", data);

                        // Update status bar text, removing backend attempt counts
                        currentStatusText = data.status || currentStatusText;
                        const simpleStatus = currentStatusText.replace(/\s*\(Attempt \d+\/\d+\)/i, '');
                        setStatus(simpleStatus, !!data.error); // Set error flag if data contains an error field

                         // Store analysis results if received
                         if (data.analysis_results) {
                             analysisResultsReceived = data.analysis_results;
                             // Update placeholder with these results immediately
                             updateStellarMessagePlaceholder(placeholderId, simpleStatus || "Processing...", false, analysisResultsReceived);
                         } else {
                              // Update placeholder status without results
                              updateStellarMessagePlaceholder(placeholderId, simpleStatus || "Processing...", false);
                         }


                        // Handle stream-level errors reported by backend
                        if (data.error) {
                            console.error("SSE Stream Error:", data.status, data.error, data.details);
                             const errMsg = data.error || data.status || "Unknown streaming error";
                             cleanup(true, errMsg + (data.details ? ` Details: ${data.details}`: '')); // Cleanup with error
                             streamEndedCleanly = true; // Mark as ended (due to error) to prevent onerror cleanup
                             return; // Stop processing this message
                        }


                        // Store the analysis context string if received (for final message display)
                        if (data.analysis_context_used) {
                            analysisContextReceived = data.analysis_context_used;
                        }


                         // Check if this is the final message content
                         const finalContent = data.refined_query || data.result; // Look for final content fields
                         // Determine if this message signals the end of the useful stream content
                         const isFinalMessage = (data.status === 'refined_ready' || data.status === 'display_result') && finalContent !== undefined;


                         if (isFinalMessage) {
                             streamEndedCleanly = true; // Mark stream as ended normally
                             fullResponseContent = finalContent; // Store the final content
                             const messageDbId = data.message_id || placeholderId; // Use DB ID if available

                             console.log(`Finalizing message ${placeholderId} -> ${messageDbId}. Context used: ${!!analysisContextReceived}`);
                             // Replace placeholder with final content and analysis indicator
                             finalizeStellarMessage(placeholderId, fullResponseContent, messageDbId, analysisContextReceived);


                              // Add View Paper button if URL is provided (for research output)
                              if (data.status === 'display_result' && data.file_url) {
                                 const finalMsgDiv = messagesDiv.querySelector(`.message[data-id="${messageDbId}"]`);
                                 if (finalMsgDiv && finalMsgDiv.classList.contains('research-output')) {
                                      const buttonsDiv = finalMsgDiv.querySelector('.message-buttons');
                                      if(buttonsDiv) {
                                           let viewBtn = buttonsDiv.querySelector('.view-html-btn');
                                           if (!viewBtn) { // Add button if it doesn't exist
                                                viewBtn = document.createElement("a");
                                                viewBtn.classList.add("download-btn", "view-html-btn"); // Reuse styling
                                                viewBtn.target = "_blank"; // Open in new tab
                                                buttonsDiv.appendChild(viewBtn);
                                           }
                                           viewBtn.textContent = "View Paper";
                                           viewBtn.href = data.file_url; // Set link
                                      }
                                 }
                             }

                             cleanup(false); // Perform normal cleanup
                             // No return needed here, allow function to naturally end after cleanup
                         }

                    } catch (err) {
                         console.error("SSE Parse/Processing Error:", event.data, err);
                          // Update UI to show error
                          updateStellarMessagePlaceholder(placeholderId, "Error processing stream update.", true);
                          setStatus("Stream processing error", true);
                          // Don't cleanup here, let onerror handle connection issues if they arise
                    }
                };

                source.onerror = (err) => {
                     console.error("SSE Connection Error:", err);

                     // Only trigger cleanup if the stream didn't end cleanly before the error
                     if (!streamEndedCleanly) {
                          console.error("SSE connection error occurred before stream completion.");
                          cleanup(true, "Connection error during processing.");
                     } else {
                          console.log("SSE connection closed/errored after stream finished normally.");
                          // Perform normal cleanup just in case something was missed
                          cleanup(false);
                     }
                };

            } catch (err) {
                console.error("Error initiating stream:", err);
                cleanup(true, `Error starting stream: ${err.message}`); // Cleanup with error
            }
        }



        function toggleAnalysisDetails(messageElement) {
            if (!messageElement) return;
            // Find the specific details div within the message
            const detailsDiv = messageElement.querySelector('.analysis-content');
            if (detailsDiv) {
                const isHidden = detailsDiv.style.display === 'none';
                // Toggle visibility
                detailsDiv.style.display = isHidden ? 'block' : 'none';

                // If revealing, highlight code and scroll into view
                if (isHidden) {
                     // Find code blocks within the details and highlight if not already done
                    detailsDiv.querySelectorAll('.formatted-analysis-context pre code').forEach(codeEl => {
                         if (!codeEl.dataset.highlighted) { // Avoid re-highlighting
                              try {
                                   if (typeof hljs !== 'undefined') {
                                       hljs.highlightElement(codeEl);
                                       codeEl.dataset.highlighted = 'yes'; // Mark as highlighted
                                   }
                               }
                              catch(e) { console.warn("Highlight error on reveal", e); }
                         }
                    });
                    // Scroll the details div into view smoothly
                     setTimeout(() => detailsDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' }), 100); // Slight delay
                }
            }
        }


        function loadHistory() {
             // Prevent multiple loads
             if (historyLoaded || !messagesDiv) return;
             historyLoaded = true;
             console.log("Loading history...");
             messagesDiv.innerHTML = ""; // Clear existing messages
             setStatus("Loading history...");

             fetch('/get_history', { credentials: 'include' }) // Include credentials (cookies)
                 .then(response => {
                     if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                     return response.json();
                 })
                 .then(data => {
                     const ids = new Set(); // Track IDs to prevent duplicates
                     if (data.history && Array.isArray(data.history) && data.history.length > 0) {
                         data.history.forEach(msg => {
                             // Basic validation for each message
                             if (!msg?.id || ids.has(msg.id)) { console.warn("Skipping message with missing or duplicate ID:", msg); return; }
                             ids.add(msg.id);
                             const content = msg.message_content || "";
                             const msgId = msg.id; // Use the ID from DB
                             const messageType = msg.message_type || "stellar";
                             const analysisContext = msg.file_analysis_context || null;

                             try {
                                 // --- Render based on message type ---
                                 if (messageType === "user") {
                                     appendUserMessage(content, msgId);
                                 } else if (messageType === "nebula_output") {
                                     // Reconstruct Nebula message from stored data
                                     const reportUrl = msg.report_url || null;
                                     const processId = msgId.replace('nebula-output-', '') || Date.now(); // Infer process ID
                                     const nebulaMsgElement = createNebulaMessageContainer(processId); // Create the container

                                     // Temporary state to pass to display function (avoids modifying global nebulaProcess)
                                     let tempNebulaState = { messageElement: nebulaMsgElement, planOutput: null, frontendOutput: null, backendOutput: null, verificationOutput: null };
                                     let stepOutputs = msg.nebula_output || {}; // Get step outputs from DB field

                                     // Sort steps to display in order
                                     const sortedSteps = Object.keys(stepOutputs).map(s => parseInt(s.replace('step',''))).filter(n => !isNaN(n)).sort((a, b) => a - b);

                                     // Display each step's output
                                     sortedSteps.forEach(stepNum => {
                                          const stepKey = `step${stepNum}`;
                                          if (stepOutputs[stepKey]) {
                                              // Temporarily swap global nebulaProcess for display function
                                              let originalNebulaProcess = nebulaProcess;
                                              nebulaProcess = tempNebulaState; // Use temp state with correct messageElement
                                              displayNebulaStepOutput(stepNum, stepOutputs[stepKey]);
                                              nebulaProcess = originalNebulaProcess; // Restore global state

                                              // Remove action buttons from historical Nebula steps
                                              const stepDiv = tempNebulaState.messageElement?.querySelector(`.nebula-step-content[data-step="${stepNum}"]`);
                                              const actionsDiv = stepDiv?.querySelector('.nebula-step-actions');
                                              if(actionsDiv) actionsDiv.remove();
                                          }
                                     });

                                     // Update status and add report link if available
                                     const statusSpan = tempNebulaState.messageElement?.querySelector('.nebula-status');
                                     if (statusSpan) statusSpan.textContent = `(Loaded from history)`;

                                     const summaryDiv = tempNebulaState.messageElement?.querySelector('.nebula-final-summary');
                                     if (summaryDiv && reportUrl) {
                                          summaryDiv.innerHTML = ''; // Clear any default summary
                                          const buttonsDiv = document.createElement('div');
                                          buttonsDiv.classList.add('message-buttons'); buttonsDiv.style.marginTop = '10px';
                                          const downloadReportBtn = document.createElement("a");
                                          downloadReportBtn.textContent = "Download Report (MD)"; downloadReportBtn.classList.add("nebula-download-btn");
                                          downloadReportBtn.href = reportUrl; downloadReportBtn.target = "_blank";
                                          try { downloadReportBtn.download = reportUrl.substring(reportUrl.lastIndexOf('/') + 1); } catch {}
                                          buttonsDiv.appendChild(downloadReportBtn); summaryDiv.appendChild(buttonsDiv);
                                     }
                                 } else { // Default: Standard Stellar message or Research output
                                     const isResearch = msg.is_research_output;
                                     const msgDiv = document.createElement("div");
                                     msgDiv.classList.add("message", "stellar-msg");
                                     if (isResearch) msgDiv.classList.add("research-output");
                                     msgDiv.dataset.id = msgId;

                                     const contentDiv = document.createElement("div");
                                     contentDiv.classList.add("message-content");

                                     // Parse markdown, process code blocks, add analysis indicator
                                     let htmlContent = marked.parse(content || "");
                                     htmlContent = wrapTables(htmlContent);
                                     contentDiv.innerHTML = htmlContent;
                                     msgDiv.appendChild(contentDiv);
                                     processCodeBlocks(contentDiv);
                                     if (analysisContext) {
                                         addAnalysisIndicator(msgDiv, analysisContext);
                                     }

                                     // Add research-specific buttons and links
                                     if (isResearch) {
                                         createAndAppendResearchButtons(msgDiv, msgId, contentDiv.innerHTML);
                                         if (msg.html_url) { // Link to view pre-rendered paper if available
                                             const buttonsDiv = msgDiv.querySelector('.message-buttons');
                                             if (buttonsDiv) {
                                                 const viewBtn = document.createElement("a");
                                                 viewBtn.classList.add("download-btn", "view-html-btn"); // Reuse styling
                                                 viewBtn.textContent = "View Paper";
                                                 viewBtn.href = msg.html_url;
                                                 viewBtn.target = "_blank";
                                                 buttonsDiv.appendChild(viewBtn);
                                             }
                                         }
                                     }

                                     if (messagesDiv) messagesDiv.appendChild(msgDiv);

                                     // Render math equations (including within analysis details)
                                     setTimeout(() => {
                                         renderMath(contentDiv);
                                         const analysisContentEl = msgDiv.querySelector('.analysis-content .formatted-analysis-context');
                                         if(analysisContentEl) renderMath(analysisContentEl);
                                     }, 150); // Delay slightly
                                 }
                                // --- End Render based on message type ---
                             } catch (error) {
                                 console.error("Error processing historical message:", msgId, error);
                                 // Append an error message in the chat for this specific failed message
                                 appendStellarMessage(`*Error displaying historical message ID ${msgId}*`, msgId + '_err');
                             }
                         });
                         console.log(`History loaded (${data.history.length} messages processed).`);
                         setTimeout(scrollToBottom, 400); // Scroll down after history is rendered
                     } else {
                         // If history is empty (backend confirms), insert the welcome message
                         console.log("No history found or history is empty.");
                         const welcomeMessage = "Heyy there! I'm Stellar, and I can help you with research papers using Spectrum Mode, which includes Spectral Search! and building websites/apps with Nebula Mode! (Only exclusive to Crimson and Obsidian models). You can even Preview code blocks to see them live! I've got different models too, like Emerald for quick stuff or Obsidian for super complex things! âœ¨";
                         appendStellarMessage(welcomeMessage, "welcome-msg");
                     }
                 })
                 .catch(error => {
                     console.error('Failed to load history:', error);
                     appendStellarMessage(`Error loading history: ${error.message}.`, Date.now() + '_hist_err');
                     setStatus("Error loading history", true);
                     historyLoaded = false; // Allow retry on next load maybe?
                 })
                 .finally(() => {
                     // Final UI updates after history load attempt
                     updateModelSelectTheme(); // Ensure theme matches default model
                     updateModelSelectWidth();
                     adjustTextareaHeight();
                     // Determine final status bar state
                     const shouldBeIdle = !isProcessing && !nebulaProcess.isActive && pendingAnalysisFiles.length === 0 && analysisProgressArea?.childElementCount === 0;
                     if (shouldBeIdle) setStatus("Idle");
                     else setStatus(currentStatusText); // Restore current status if busy
                 });
        }


        // --- Event Listeners ---
        if (sendBtn) sendBtn.addEventListener("click", handleSend);
        if (chatInput) {
            chatInput.addEventListener("keydown", (e) => { if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); handleSend(); } });
            chatInput.addEventListener("input", adjustTextareaHeight);
        }
        if (spectrumBtn) spectrumBtn.addEventListener("click", toggleSpectrumMode);
        if (spectrumSearchBtn) { spectrumSearchBtn.addEventListener("click", () => { if (isResearchMode && !spectrumSearchBtn.disabled) { updateSpectrumSearchButtonState(!useSpectrumSearch); } }); }
        if (nebulaBtn) nebulaBtn.addEventListener("click", toggleNebulaMode);
        if (modelSelect) { modelSelect.addEventListener("change", () => { updateModelSelectWidth(); updateModelSelectTheme(); enableDisableModelOptions(isNebulaMode); }); }
        if (cancelEditBtn) cancelEditBtn.addEventListener("click", hideEditModal);
        if (saveEditBtn) { saveEditBtn.addEventListener("click", () => { if (currentEditingMsg && currentEditingMsgId) { const md = editMarkdownInput.value; let html = ""; try { html = marked.parse(md || ""); html = wrapTables(html); } catch (e) { console.error("Save Parse Err:", e); html = "<p style='color: red;'>Error parsing saved content.</p>"; } const contentDiv = currentEditingMsg.querySelector('.message-content'); if (contentDiv) { contentDiv.innerHTML = html; processCodeBlocks(contentDiv); setTimeout(() => renderMath(contentDiv), 150); createAndAppendResearchButtons(currentEditingMsg, currentEditingMsgId, contentDiv.innerHTML); console.log(`Saved edit for message: ${currentEditingMsgId}`); } else { console.error("Save Edit Error: Content div not found."); } } else { console.error("Save Edit Error: No message context."); } hideEditModal(); }); }
        if (cancelRegenerateBtn) cancelRegenerateBtn.addEventListener("click", hideRegenerateModal);
        if (saveRegenerateBtn) saveRegenerateBtn.addEventListener("click", handleSaveRegeneration);
        if (regenerateWithoutFeedbackBtn) { regenerateWithoutFeedbackBtn.addEventListener("click", () => { triggerRegeneration(currentRegeneratingStep); }); }
        if (clearHistoryBtn) {
            clearHistoryBtn.addEventListener("click", async () => {
                // Prevent clearing while processing or waiting for Nebula confirmation
                if (isProcessing || (isNebulaMode && nebulaProcess.isActive && !isProcessing)) { const msg = isProcessing ? "Cannot clear history while processing." : `Cannot clear history while waiting for confirmation on Step ${nebulaProcess.currentStep}.`; setStatus(msg, true); setTimeout(() => setStatus(currentStatusText, false), 2000); return; }
                // Cleanup any active Nebula process before clearing
                if (nebulaProcess.isActive) { cleanupNebulaProcess(true, "Aborted by history clear"); }
                setStatus("Clearing history...");
                try {
                    const response = await fetch("/clear_history", { method: "POST" }); if (!response.ok) { let msg = `HTTP ${response.status}`; try { const d = await response.json(); msg = d.message || msg; } catch(e){} throw new Error(msg); }
                    const data = await response.json(); if (data.status !== 'Success') throw new Error(data.message || "Backend clear failed");
                    console.log("Backend history cleared.");
                    // Reset frontend state
                    lastRefinedQuery = ""; historyLoaded = false; pendingAnalysisFiles = []; updatePendingFilesIndicator(); messagesDiv.innerHTML = ""; analysisProgressArea.innerHTML = ""; analysisProgressArea.style.display = 'none'; deactivateAllModes(); // Ensure all modes are off
                    loadHistory(); // Reload (will show welcome message)
                    setStatus("History cleared"); setTimeout(() => { if (!isProcessing && !nebulaProcess.isActive && pendingAnalysisFiles.length === 0 && analysisProgressArea?.childElementCount === 0) setStatus("Idle"); }, 1500);
                } catch (err) { console.error("Clear History Error:", err); appendStellarMessage(`Error clearing history: ${err.message}`, Date.now() + '_clr_err'); setStatus("Error clearing history", true); setTimeout(() => setStatus(currentStatusText, false), 3000); }
            });
        }
        if (fileUploadInput) {
             fileUploadInput.addEventListener('change', handleFileUpload);
        }

         // Event Delegation for dynamically added elements (Analysis Indicator)
         if (messagesDiv) {
            messagesDiv.addEventListener('click', function(event) {
                const target = event.target;
                // Check if the clicked element or its ancestor is the analysis indicator
                const clickableElement = target.closest('.message-content .analysis-placeholder, .message-content .analysis-indicator.clickable');
                if (clickableElement) {
                     const messageElement = clickableElement.closest('.message'); // Find the parent message div
                     if (messageElement) {
                         toggleAnalysisDetails(messageElement); // Call the toggle function
                     }
                }
            });
        }

        // --- Initial Page Load Logic ---
        window.addEventListener("load", () => {
            // --- Explicitly Reset Nebula State on Load ---
            resetNebulaProcessState();
            // --- End Explicit Reset ---

            if (modelSelect) { updateModelSelectTheme(); updateModelSelectWidth(); }
            loadHistory(); // Load chat history from backend
            // Initial UI adjustments after a short delay
            setTimeout(() => {
                adjustTextareaHeight();
                updateStatusBarPosition();
                scrollToBottom();
            }, 300);
        }, { once: true }); // Run only once on initial load

        window.addEventListener("resize", () => { updateStatusBarPosition(); updateModelSelectWidth(); }); // Adjust UI on resize

    </script>


</body>

</html>